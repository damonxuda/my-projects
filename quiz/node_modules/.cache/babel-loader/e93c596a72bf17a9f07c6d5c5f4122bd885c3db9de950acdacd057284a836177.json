{"ast":null,"code":"// src/utils/markdownParser.js\n// MarkdownËß£ÊûêÂºïÊìé - ‰∏ìÈó®Ëß£ÊûêAIÁîüÊàêÁöÑÈ¢òÁõÆÊñáÊ°£\n\nimport { MARKDOWN_PATTERNS, QUESTION_TYPES } from './constants.js';\n\n/**\n * Ëß£ÊûêMarkdownÊñáÊ°£ÔºåÊèêÂèñÈ¢òÁõÆ‰ø°ÊÅØ\n * @param {string} markdownText - MarkdownÊñáÊ°£ÂÜÖÂÆπ\n * @param {string[]} baseTags - Âü∫Á°ÄÊ†áÁ≠æÔºàËØæÁ®ã‰ø°ÊÅØÔºâ\n * @returns {Object[]} - Ëß£ÊûêÂá∫ÁöÑÈ¢òÁõÆÊï∞ÁªÑ\n */\nexport const parseMarkdownQuestions = (markdownText, baseTags = []) => {\n  console.log('üìñ ÂºÄÂßãËß£ÊûêMarkdownÊñáÊ°£');\n  console.log('üìù ÊñáÊ°£ÈïøÂ∫¶:', markdownText.length);\n  console.log('üè∑Ô∏è Âü∫Á°ÄÊ†áÁ≠æ:', baseTags);\n  if (!markdownText || typeof markdownText !== 'string') {\n    console.warn('‚ùå ËæìÂÖ•ÊñáÊ°£‰∏∫Á©∫ÊàñÊ†ºÂºèÈîôËØØ');\n    return [];\n  }\n  const lines = markdownText.split('\\n');\n  const questions = [];\n  let currentQuestion = null;\n  let currentSection = 'question'; // question, solution, answer\n  let lineNumber = 0;\n  console.log(`üìÑ ÊÄªË°åÊï∞: ${lines.length}`);\n  for (const line of lines) {\n    lineNumber++;\n    const trimmedLine = line.trim();\n\n    // Ë∑≥ËøáÁ©∫Ë°å\n    if (!trimmedLine) continue;\n\n    // Ê£ÄÊü•ÊòØÂê¶ÊòØÊñ∞È¢òÁõÆÂºÄÂßã\n    const questionMatch = matchQuestionPattern(trimmedLine);\n    if (questionMatch) {\n      // ‰øùÂ≠ò‰∏ä‰∏ÄÈÅìÈ¢òÁõÆ\n      if (currentQuestion && isValidQuestion(currentQuestion)) {\n        const processedQuestion = processQuestion(currentQuestion, baseTags);\n        questions.push(processedQuestion);\n        console.log(`‚úÖ ÂÆåÊàêÈ¢òÁõÆ: ${processedQuestion.questionType}`);\n      }\n\n      // ÂºÄÂßãÊñ∞È¢òÁõÆ\n      console.log(`üÜï ÂèëÁé∞Êñ∞È¢òÁõÆ: ${questionMatch.type} (Ë°å ${lineNumber})`);\n      currentQuestion = {\n        questionType: questionMatch.type,\n        questionText: questionMatch.content || '',\n        answer: '',\n        solutionSteps: '',\n        rawLine: trimmedLine,\n        startLine: lineNumber\n      };\n      currentSection = 'question';\n      continue;\n    }\n\n    // Â¶ÇÊûúÊ≤°ÊúâÂΩìÂâçÈ¢òÁõÆÔºåË∑≥ËøáËøôË°å\n    if (!currentQuestion) continue;\n\n    // Ê£ÄÊü•Ëß£È¢òÊÄùË∑ØÊ†áËØÜ\n    if (isSolutionSection(trimmedLine)) {\n      console.log(`üí° ËøõÂÖ•Ëß£È¢òÊÄùË∑ØÈÉ®ÂàÜ (Ë°å ${lineNumber})`);\n      currentSection = 'solution';\n      continue;\n    }\n\n    // Ê£ÄÊü•Á≠îÊ°àÊ†áËØÜ\n    const answerMatch = matchAnswerPattern(trimmedLine);\n    if (answerMatch) {\n      console.log(`‚úÖ ÊâæÂà∞Á≠îÊ°à (Ë°å ${lineNumber}): ${answerMatch.substring(0, 50)}...`);\n      currentQuestion.answer = answerMatch;\n      continue;\n    }\n\n    // Â§ÑÁêÜÊôÆÈÄöÂÜÖÂÆπË°å\n    if (isContentLine(trimmedLine)) {\n      processContentLine(currentQuestion, trimmedLine, currentSection);\n    }\n  }\n\n  // Â§ÑÁêÜÊúÄÂêé‰∏ÄÈÅìÈ¢òÁõÆ\n  if (currentQuestion && isValidQuestion(currentQuestion)) {\n    const processedQuestion = processQuestion(currentQuestion, baseTags);\n    questions.push(processedQuestion);\n    console.log(`‚úÖ ÂÆåÊàêÊúÄÂêé‰∏ÄÈ¢ò: ${processedQuestion.questionType}`);\n  }\n  console.log(`üéâ Ëß£ÊûêÂÆåÊàê! ÂÖ±Ëß£ÊûêÂá∫ ${questions.length} ÈÅìÈ¢òÁõÆ`);\n  return questions;\n};\n\n/**\n * ÂåπÈÖçÈ¢òÁõÆÊ®°Âºè\n */\nconst matchQuestionPattern = line => {\n  for (const pattern of MARKDOWN_PATTERNS.questionPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return {\n        type: match[1],\n        // ‰æã1, ‰π†È¢ò1Á≠â\n        content: match[2] || '',\n        // È¢òÁõÆÂÜÖÂÆπ\n        fullMatch: match[0]\n      };\n    }\n  }\n  return null;\n};\n\n/**\n * ÂåπÈÖçÁ≠îÊ°àÊ®°Âºè\n */\nconst matchAnswerPattern = line => {\n  for (const pattern of MARKDOWN_PATTERNS.answerPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return match[1].replace(/\\*+/g, '').trim();\n    }\n  }\n  return null;\n};\n\n/**\n * Ê£ÄÊü•ÊòØÂê¶ÊòØËß£È¢òÊÄùË∑ØÈÉ®ÂàÜ\n */\nconst isSolutionSection = line => {\n  return MARKDOWN_PATTERNS.solutionKeywords.some(keyword => line.includes(keyword));\n};\n\n/**\n * Ê£ÄÊü•ÊòØÂê¶ÊòØÊúâÊïàÁöÑÂÜÖÂÆπË°å\n */\nconst isContentLine = line => {\n  // ÊéíÈô§MarkdownÊ†áËÆ∞Ë°å\n  const excludePatterns = [/^#+\\s/,\n  // Ê†áÈ¢òË°å\n  /^-{3,}$/,\n  // ÂàÜÈöîÁ∫ø\n  /^\\*{3,}$/,\n  // ÂàÜÈöîÁ∫ø\n  /^={3,}$/,\n  // ÂàÜÈöîÁ∫ø\n  /^\\s*$/ // Á©∫Ë°å\n  ];\n  return !excludePatterns.some(pattern => pattern.test(line)) && line.length > 2;\n};\n\n/**\n * Â§ÑÁêÜÂÜÖÂÆπË°å\n */\nconst processContentLine = (question, line, section) => {\n  if (section === 'solution') {\n    question.solutionSteps += line + '\\n';\n  } else if (section === 'question') {\n    // Â¶ÇÊûúÈ¢òÁõÆÊñáÂ≠ó‰∏∫Á©∫ÔºåËøôÊòØÁ¨¨‰∏ÄË°å\n    if (!question.questionText || question.questionText.trim() === '') {\n      question.questionText = line;\n    } else {\n      // Âê¶ÂàôËøΩÂä†Âà∞È¢òÁõÆÂÜÖÂÆπÔºàÁî®Á©∫Ê†ºËøûÊé•Ôºâ\n      question.questionText += ' ' + line;\n    }\n  }\n};\n\n/**\n * È™åËØÅÈ¢òÁõÆÊòØÂê¶ÊúâÊïà\n */\nconst isValidQuestion = question => {\n  const hasValidType = QUESTION_TYPES.includes(question.questionType);\n  const hasContent = question.questionText && question.questionText.trim().length > 5;\n  if (!hasValidType) {\n    console.warn(`‚ö†Ô∏è Êó†ÊïàÁöÑÈ¢òÁõÆÁ±ªÂûã: ${question.questionType}`);\n  }\n  if (!hasContent) {\n    console.warn(`‚ö†Ô∏è È¢òÁõÆÂÜÖÂÆπËøáÁü≠Êàñ‰∏∫Á©∫: ${question.questionText}`);\n  }\n  return hasValidType && hasContent;\n};\n\n/**\n * Â§ÑÁêÜÈ¢òÁõÆÔºåÊ∑ªÂä†Âü∫Á°Ä‰ø°ÊÅØ\n */\nconst processQuestion = (rawQuestion, baseTags) => {\n  return {\n    questionType: rawQuestion.questionType,\n    questionText: cleanText(rawQuestion.questionText),\n    answer: cleanText(rawQuestion.answer),\n    solutionSteps: cleanText(rawQuestion.solutionSteps),\n    tags: [...baseTags],\n    // ‰ΩøÁî®‰º†ÂÖ•ÁöÑÂü∫Á°ÄÊ†áÁ≠æ\n    createdAt: new Date().toISOString(),\n    metadata: {\n      parsedAt: new Date().toISOString(),\n      startLine: rawQuestion.startLine,\n      originalLength: rawQuestion.questionText.length\n    }\n  };\n};\n\n/**\n * Ê∏ÖÁêÜÊñáÊú¨ÂÜÖÂÆπ\n */\nconst cleanText = text => {\n  if (!text || typeof text !== 'string') return '';\n  return text.trim() // ÂéªÈô§È¶ñÂ∞æÁ©∫Ê†º\n  .replace(/\\*+/g, '') // ÂéªÈô§MarkdownÁ≤ó‰ΩìÊ†áËÆ∞\n  .replace(/_{2,}/g, '') // ÂéªÈô§‰∏ãÂàíÁ∫ø\n  .replace(/\\s+/g, ' ') // ÂêàÂπ∂Â§ö‰∏™Á©∫Ê†º\n  .replace(/\\n\\s*\\n/g, '\\n') // ÂêàÂπ∂Â§ö‰∏™Êç¢Ë°å\n  .trim();\n};\n\n/**\n * È™åËØÅËß£ÊûêÁªìÊûú\n */\nexport const validateParseResult = questions => {\n  const validation = {\n    isValid: true,\n    totalQuestions: questions.length,\n    issues: [],\n    statistics: {\n      byType: {},\n      averageLength: 0,\n      withAnswers: 0,\n      withSolutions: 0\n    }\n  };\n  let totalLength = 0;\n  questions.forEach((question, index) => {\n    // ÁªüËÆ°È¢òÁõÆÁ±ªÂûã\n    validation.statistics.byType[question.questionType] = (validation.statistics.byType[question.questionType] || 0) + 1;\n\n    // ÁªüËÆ°ÈïøÂ∫¶\n    totalLength += question.questionText.length;\n\n    // ÁªüËÆ°Á≠îÊ°àÂíåËß£È¢òÊÄùË∑Ø\n    if (question.answer && question.answer.trim()) {\n      validation.statistics.withAnswers++;\n    }\n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      validation.statistics.withSolutions++;\n    }\n\n    // Ê£ÄÊü•ÈóÆÈ¢ò\n    if (question.questionText.length < 10) {\n      validation.issues.push(`È¢òÁõÆ ${index + 1} ÂÜÖÂÆπËøáÁü≠`);\n    }\n    if (!question.answer || !question.answer.trim()) {\n      validation.issues.push(`È¢òÁõÆ ${index + 1} Áº∫Â∞ëÁ≠îÊ°à`);\n    }\n    if (question.tags.length === 0) {\n      validation.issues.push(`È¢òÁõÆ ${index + 1} Áº∫Â∞ëÊ†áÁ≠æ`);\n    }\n  });\n  validation.statistics.averageLength = questions.length > 0 ? Math.round(totalLength / questions.length) : 0;\n  validation.isValid = validation.issues.length === 0;\n  return validation;\n};\n\n/**\n * ÁîüÊàêËß£ÊûêÊä•Âëä\n */\nexport const generateParseReport = (questions, originalText) => {\n  const validation = validateParseResult(questions);\n  const report = {\n    timestamp: new Date().toISOString(),\n    input: {\n      originalLength: originalText.length,\n      lineCount: originalText.split('\\n').length\n    },\n    output: {\n      questionCount: questions.length,\n      successRate: questions.length > 0 ? '100%' : '0%'\n    },\n    validation,\n    recommendations: []\n  };\n\n  // ÁîüÊàêÂª∫ËÆÆ\n  if (validation.statistics.withAnswers < questions.length) {\n    report.recommendations.push('Âª∫ËÆÆ‰∏∫ÊâÄÊúâÈ¢òÁõÆÊ∑ªÂä†Ê†áÂáÜÁ≠îÊ°à');\n  }\n  if (validation.statistics.withSolutions < questions.length * 0.8) {\n    report.recommendations.push('Âª∫ËÆÆ‰∏∫Êõ¥Â§öÈ¢òÁõÆÊ∑ªÂä†Ëß£È¢òÊÄùË∑Ø');\n  }\n  if (validation.issues.length > 0) {\n    report.recommendations.push('ËØ∑Ê£ÄÊü•Âπ∂‰øÆÂ§çÂèëÁé∞ÁöÑÈóÆÈ¢ò');\n  }\n  return report;\n};\n\n/**\n * ÂØºÂá∫Ëß£ÊûêÁªüËÆ°\n */\nexport const getParseStatistics = questions => {\n  const stats = {\n    total: questions.length,\n    byType: {},\n    byCategory: {},\n    quality: {\n      withAnswers: 0,\n      withSolutions: 0,\n      averageTextLength: 0,\n      averageAnswerLength: 0\n    }\n  };\n  let totalTextLength = 0;\n  let totalAnswerLength = 0;\n  questions.forEach(question => {\n    // ÊåâÁ±ªÂûãÁªüËÆ°\n    stats.byType[question.questionType] = (stats.byType[question.questionType] || 0) + 1;\n\n    // ÊåâÂàÜÁ±ªÁªüËÆ°\n    const categories = question.tags.filter(tag => ['ËÆ°ÁÆó', 'ËÆ°Êï∞', 'Âá†‰Ωï', 'Êï∞ËÆ∫', 'Â∫îÁî®È¢ò', 'Ë°åÁ®ã', 'ÁªÑÂêà'].includes(tag));\n    categories.forEach(category => {\n      stats.byCategory[category] = (stats.byCategory[category] || 0) + 1;\n    });\n\n    // Ë¥®ÈáèÁªüËÆ°\n    totalTextLength += question.questionText.length;\n    if (question.answer) {\n      stats.quality.withAnswers++;\n      totalAnswerLength += question.answer.length;\n    }\n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      stats.quality.withSolutions++;\n    }\n  });\n  stats.quality.averageTextLength = questions.length > 0 ? Math.round(totalTextLength / questions.length) : 0;\n  stats.quality.averageAnswerLength = stats.quality.withAnswers > 0 ? Math.round(totalAnswerLength / stats.quality.withAnswers) : 0;\n  return stats;\n};\n\n/**\n * Ê£ÄÊµãÈáçÂ§çÈ¢òÁõÆ\n */\nexport const detectDuplicates = (newQuestions, existingQuestions) => {\n  const duplicates = [];\n  const uniqueQuestions = [];\n  newQuestions.forEach((newQ, index) => {\n    const isExisting = existingQuestions.some(existingQ => isSimilarQuestion(newQ, existingQ));\n    const isDuplicateInBatch = uniqueQuestions.some(uniqueQ => isSimilarQuestion(newQ, uniqueQ));\n    if (isExisting || isDuplicateInBatch) {\n      duplicates.push({\n        index,\n        question: newQ,\n        reason: isExisting ? 'exists_in_database' : 'duplicate_in_batch'\n      });\n    } else {\n      uniqueQuestions.push(newQ);\n    }\n  });\n  return {\n    duplicates,\n    uniqueQuestions,\n    duplicateCount: duplicates.length,\n    uniqueCount: uniqueQuestions.length\n  };\n};\n\n/**\n * Âà§Êñ≠‰∏§‰∏™È¢òÁõÆÊòØÂê¶Áõ∏‰ºº\n */\nconst isSimilarQuestion = (q1, q2) => {\n  // ÁÆÄÂçïÁöÑÁõ∏‰ººÂ∫¶Ê£ÄÊµãÔºöÊØîËæÉÈ¢òÁõÆÂºÄÂ§¥30‰∏™Â≠óÁ¨¶\n  const text1 = q1.questionText.substring(0, 30).replace(/\\s+/g, '');\n  const text2 = q2.questionText.substring(0, 30).replace(/\\s+/g, '');\n  return text1 === text2;\n};\n\n/**\n * È¢ÑÂ§ÑÁêÜMarkdownÊñáÊ°£\n */\nexport const preprocessMarkdown = markdownText => {\n  if (!markdownText || typeof markdownText !== 'string') {\n    return '';\n  }\n  return markdownText\n  // Áªü‰∏ÄÊç¢Ë°åÁ¨¶\n  .replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n')\n\n  // Ê∏ÖÁêÜÂ§ö‰ΩôÁöÑÁ©∫Ë°å\n  .replace(/\\n{3,}/g, '\\n\\n')\n\n  // Áªü‰∏ÄÊ†áÈ¢òÊ†ºÂºè\n  .replace(/^#+\\s*/gm, '## ')\n\n  // Ê∏ÖÁêÜË°åÈ¶ñÁ©∫Ê†º\n  .replace(/^\\s+/gm, '')\n\n  // Ê∏ÖÁêÜË°åÂ∞æÁ©∫Ê†º\n  .replace(/\\s+$/gm, '').trim();\n};\n\n/**\n * ÊèêÂèñÊñáÊ°£ÂÖÉ‰ø°ÊÅØ\n */\nexport const extractDocumentMeta = markdownText => {\n  const meta = {\n    hasQuestions: false,\n    questionCount: 0,\n    hasAnswers: false,\n    hasSolutions: false,\n    estimatedProcessingTime: 0,\n    detectedPatterns: []\n  };\n  if (!markdownText) return meta;\n\n  // Ê£ÄÊµãÈ¢òÁõÆÊ®°Âºè\n  MARKDOWN_PATTERNS.questionPatterns.forEach((pattern, index) => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasQuestions = true;\n      meta.questionCount = Math.max(meta.questionCount, matches.length);\n      meta.detectedPatterns.push({\n        pattern: index,\n        matches: matches.length,\n        examples: matches.slice(0, 3)\n      });\n    }\n  });\n\n  // Ê£ÄÊµãÁ≠îÊ°à\n  MARKDOWN_PATTERNS.answerPatterns.forEach(pattern => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasAnswers = true;\n    }\n  });\n\n  // Ê£ÄÊµãËß£È¢òÊÄùË∑Ø\n  meta.hasSolutions = MARKDOWN_PATTERNS.solutionKeywords.some(keyword => markdownText.includes(keyword));\n\n  // ‰º∞ÁÆóÂ§ÑÁêÜÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ\n  meta.estimatedProcessingTime = Math.max(100, markdownText.length / 100);\n  return meta;\n};\n\n/**\n * ‰øÆÂ§çÂ∏∏ËßÅÁöÑÊ†ºÂºèÈóÆÈ¢ò\n */\nexport const fixCommonFormatIssues = markdownText => {\n  return markdownText\n  // ‰øÆÂ§çÈ¢òÁõÆÁºñÂè∑Ê†ºÂºè\n  .replace(/‰æã(\\d+)[\\.ÔºéÔºö:]/g, '‰æã$1. ').replace(/‰π†È¢ò(\\d+)[\\.ÔºéÔºö:]/g, '‰π†È¢ò$1. ')\n\n  // ‰øÆÂ§çÁ≠îÊ°àÊ†ºÂºè\n  .replace(/Á≠îÊ°à[Ôºö:]\\s*/g, 'Á≠îÊ°à: ').replace(/ÊúÄÁªàÁ≠îÊ°à[Ôºö:]\\s*/g, 'ÊúÄÁªàÁ≠îÊ°à: ')\n\n  // ‰øÆÂ§çÊ†áÈ¢òÊ†ºÂºè\n  .replace(/^([‰æã‰π†]\\d+[\\.ÔºéÔºö:].*)/gm, '## $1')\n\n  // ‰øÆÂ§çËß£È¢òÊÄùË∑ØÊ†ºÂºè\n  .replace(/Ëß£È¢òÊÄùË∑Ø[Ôºö:]?\\s*/g, '### Ëß£È¢òÊÄùË∑Ø\\n')\n\n  // ‰øÆÂ§ç‰∏≠ÊñáÊ†áÁÇπ\n  .replace(/Ôºå\\s*/g, 'Ôºå').replace(/„ÄÇ\\s*/g, '„ÄÇ').replace(/Ôºõ\\s*/g, 'Ôºõ')\n\n  // Ê∏ÖÁêÜÂ§ö‰ΩôÁ©∫Ê†º\n  .replace(/\\s+/g, ' ').replace(/\\n\\s+/g, '\\n');\n};\n\n/**\n * Êô∫ËÉΩÂàÜÊÆµÂ§ÑÁêÜ\n */\nexport const intelligentSegmentation = markdownText => {\n  const segments = [];\n  const lines = markdownText.split('\\n');\n  let currentSegment = [];\n  let segmentType = 'unknown';\n  lines.forEach(line => {\n    const trimmedLine = line.trim();\n    if (!trimmedLine) {\n      if (currentSegment.length > 0) {\n        currentSegment.push('');\n      }\n      return;\n    }\n\n    // Ê£ÄÊµãÊñ∞ÁöÑÈ¢òÁõÆÊÆµËêΩ\n    const isQuestionStart = matchQuestionPattern(trimmedLine);\n    if (isQuestionStart) {\n      // ‰øùÂ≠òÂΩìÂâçÊÆµËêΩ\n      if (currentSegment.length > 0) {\n        segments.push({\n          type: segmentType,\n          content: currentSegment.join('\\n'),\n          lineCount: currentSegment.length\n        });\n      }\n\n      // ÂºÄÂßãÊñ∞ÊÆµËêΩ\n      currentSegment = [trimmedLine];\n      segmentType = 'question';\n      return;\n    }\n\n    // Ê∑ªÂä†Âà∞ÂΩìÂâçÊÆµËêΩ\n    currentSegment.push(trimmedLine);\n  });\n\n  // ‰øùÂ≠òÊúÄÂêé‰∏Ä‰∏™ÊÆµËêΩ\n  if (currentSegment.length > 0) {\n    segments.push({\n      type: segmentType,\n      content: currentSegment.join('\\n'),\n      lineCount: currentSegment.length\n    });\n  }\n  return segments;\n};","map":{"version":3,"names":["MARKDOWN_PATTERNS","QUESTION_TYPES","parseMarkdownQuestions","markdownText","baseTags","console","log","length","warn","lines","split","questions","currentQuestion","currentSection","lineNumber","line","trimmedLine","trim","questionMatch","matchQuestionPattern","isValidQuestion","processedQuestion","processQuestion","push","questionType","type","questionText","content","answer","solutionSteps","rawLine","startLine","isSolutionSection","answerMatch","matchAnswerPattern","substring","isContentLine","processContentLine","pattern","questionPatterns","match","fullMatch","answerPatterns","replace","solutionKeywords","some","keyword","includes","excludePatterns","test","question","section","hasValidType","hasContent","rawQuestion","cleanText","tags","createdAt","Date","toISOString","metadata","parsedAt","originalLength","text","validateParseResult","validation","isValid","totalQuestions","issues","statistics","byType","averageLength","withAnswers","withSolutions","totalLength","forEach","index","Math","round","generateParseReport","originalText","report","timestamp","input","lineCount","output","questionCount","successRate","recommendations","getParseStatistics","stats","total","byCategory","quality","averageTextLength","averageAnswerLength","totalTextLength","totalAnswerLength","categories","filter","tag","category","detectDuplicates","newQuestions","existingQuestions","duplicates","uniqueQuestions","newQ","isExisting","existingQ","isSimilarQuestion","isDuplicateInBatch","uniqueQ","reason","duplicateCount","uniqueCount","q1","q2","text1","text2","preprocessMarkdown","extractDocumentMeta","meta","hasQuestions","hasAnswers","hasSolutions","estimatedProcessingTime","detectedPatterns","matches","RegExp","source","max","examples","slice","fixCommonFormatIssues","intelligentSegmentation","segments","currentSegment","segmentType","isQuestionStart","join"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/quiz/src/utils/markdownParser.js"],"sourcesContent":["// src/utils/markdownParser.js\n// MarkdownËß£ÊûêÂºïÊìé - ‰∏ìÈó®Ëß£ÊûêAIÁîüÊàêÁöÑÈ¢òÁõÆÊñáÊ°£\n\nimport { MARKDOWN_PATTERNS, QUESTION_TYPES } from './constants.js';\n\n/**\n * Ëß£ÊûêMarkdownÊñáÊ°£ÔºåÊèêÂèñÈ¢òÁõÆ‰ø°ÊÅØ\n * @param {string} markdownText - MarkdownÊñáÊ°£ÂÜÖÂÆπ\n * @param {string[]} baseTags - Âü∫Á°ÄÊ†áÁ≠æÔºàËØæÁ®ã‰ø°ÊÅØÔºâ\n * @returns {Object[]} - Ëß£ÊûêÂá∫ÁöÑÈ¢òÁõÆÊï∞ÁªÑ\n */\nexport const parseMarkdownQuestions = (markdownText, baseTags = []) => {\n  console.log('üìñ ÂºÄÂßãËß£ÊûêMarkdownÊñáÊ°£');\n  console.log('üìù ÊñáÊ°£ÈïøÂ∫¶:', markdownText.length);\n  console.log('üè∑Ô∏è Âü∫Á°ÄÊ†áÁ≠æ:', baseTags);\n\n  if (!markdownText || typeof markdownText !== 'string') {\n    console.warn('‚ùå ËæìÂÖ•ÊñáÊ°£‰∏∫Á©∫ÊàñÊ†ºÂºèÈîôËØØ');\n    return [];\n  }\n\n  const lines = markdownText.split('\\n');\n  const questions = [];\n  \n  let currentQuestion = null;\n  let currentSection = 'question'; // question, solution, answer\n  let lineNumber = 0;\n\n  console.log(`üìÑ ÊÄªË°åÊï∞: ${lines.length}`);\n\n  for (const line of lines) {\n    lineNumber++;\n    const trimmedLine = line.trim();\n    \n    // Ë∑≥ËøáÁ©∫Ë°å\n    if (!trimmedLine) continue;\n\n    // Ê£ÄÊü•ÊòØÂê¶ÊòØÊñ∞È¢òÁõÆÂºÄÂßã\n    const questionMatch = matchQuestionPattern(trimmedLine);\n    \n    if (questionMatch) {\n      // ‰øùÂ≠ò‰∏ä‰∏ÄÈÅìÈ¢òÁõÆ\n      if (currentQuestion && isValidQuestion(currentQuestion)) {\n        const processedQuestion = processQuestion(currentQuestion, baseTags);\n        questions.push(processedQuestion);\n        console.log(`‚úÖ ÂÆåÊàêÈ¢òÁõÆ: ${processedQuestion.questionType}`);\n      }\n\n      // ÂºÄÂßãÊñ∞È¢òÁõÆ\n      console.log(`üÜï ÂèëÁé∞Êñ∞È¢òÁõÆ: ${questionMatch.type} (Ë°å ${lineNumber})`);\n      currentQuestion = {\n        questionType: questionMatch.type,\n        questionText: questionMatch.content || '',\n        answer: '',\n        solutionSteps: '',\n        rawLine: trimmedLine,\n        startLine: lineNumber\n      };\n      currentSection = 'question';\n      continue;\n    }\n\n    // Â¶ÇÊûúÊ≤°ÊúâÂΩìÂâçÈ¢òÁõÆÔºåË∑≥ËøáËøôË°å\n    if (!currentQuestion) continue;\n\n    // Ê£ÄÊü•Ëß£È¢òÊÄùË∑ØÊ†áËØÜ\n    if (isSolutionSection(trimmedLine)) {\n      console.log(`üí° ËøõÂÖ•Ëß£È¢òÊÄùË∑ØÈÉ®ÂàÜ (Ë°å ${lineNumber})`);\n      currentSection = 'solution';\n      continue;\n    }\n\n    // Ê£ÄÊü•Á≠îÊ°àÊ†áËØÜ\n    const answerMatch = matchAnswerPattern(trimmedLine);\n    if (answerMatch) {\n      console.log(`‚úÖ ÊâæÂà∞Á≠îÊ°à (Ë°å ${lineNumber}): ${answerMatch.substring(0, 50)}...`);\n      currentQuestion.answer = answerMatch;\n      continue;\n    }\n\n    // Â§ÑÁêÜÊôÆÈÄöÂÜÖÂÆπË°å\n    if (isContentLine(trimmedLine)) {\n      processContentLine(currentQuestion, trimmedLine, currentSection);\n    }\n  }\n\n  // Â§ÑÁêÜÊúÄÂêé‰∏ÄÈÅìÈ¢òÁõÆ\n  if (currentQuestion && isValidQuestion(currentQuestion)) {\n    const processedQuestion = processQuestion(currentQuestion, baseTags);\n    questions.push(processedQuestion);\n    console.log(`‚úÖ ÂÆåÊàêÊúÄÂêé‰∏ÄÈ¢ò: ${processedQuestion.questionType}`);\n  }\n\n  console.log(`üéâ Ëß£ÊûêÂÆåÊàê! ÂÖ±Ëß£ÊûêÂá∫ ${questions.length} ÈÅìÈ¢òÁõÆ`);\n  return questions;\n};\n\n/**\n * ÂåπÈÖçÈ¢òÁõÆÊ®°Âºè\n */\nconst matchQuestionPattern = (line) => {\n  for (const pattern of MARKDOWN_PATTERNS.questionPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return {\n        type: match[1],           // ‰æã1, ‰π†È¢ò1Á≠â\n        content: match[2] || '',  // È¢òÁõÆÂÜÖÂÆπ\n        fullMatch: match[0]\n      };\n    }\n  }\n  return null;\n};\n\n/**\n * ÂåπÈÖçÁ≠îÊ°àÊ®°Âºè\n */\nconst matchAnswerPattern = (line) => {\n  for (const pattern of MARKDOWN_PATTERNS.answerPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return match[1].replace(/\\*+/g, '').trim();\n    }\n  }\n  return null;\n};\n\n/**\n * Ê£ÄÊü•ÊòØÂê¶ÊòØËß£È¢òÊÄùË∑ØÈÉ®ÂàÜ\n */\nconst isSolutionSection = (line) => {\n  return MARKDOWN_PATTERNS.solutionKeywords.some(keyword => \n    line.includes(keyword)\n  );\n};\n\n/**\n * Ê£ÄÊü•ÊòØÂê¶ÊòØÊúâÊïàÁöÑÂÜÖÂÆπË°å\n */\nconst isContentLine = (line) => {\n  // ÊéíÈô§MarkdownÊ†áËÆ∞Ë°å\n  const excludePatterns = [\n    /^#+\\s/,           // Ê†áÈ¢òË°å\n    /^-{3,}$/,         // ÂàÜÈöîÁ∫ø\n    /^\\*{3,}$/,        // ÂàÜÈöîÁ∫ø\n    /^={3,}$/,         // ÂàÜÈöîÁ∫ø\n    /^\\s*$/            // Á©∫Ë°å\n  ];\n\n  return !excludePatterns.some(pattern => pattern.test(line)) && \n         line.length > 2;\n};\n\n/**\n * Â§ÑÁêÜÂÜÖÂÆπË°å\n */\nconst processContentLine = (question, line, section) => {\n  if (section === 'solution') {\n    question.solutionSteps += line + '\\n';\n  } else if (section === 'question') {\n    // Â¶ÇÊûúÈ¢òÁõÆÊñáÂ≠ó‰∏∫Á©∫ÔºåËøôÊòØÁ¨¨‰∏ÄË°å\n    if (!question.questionText || question.questionText.trim() === '') {\n      question.questionText = line;\n    } else {\n      // Âê¶ÂàôËøΩÂä†Âà∞È¢òÁõÆÂÜÖÂÆπÔºàÁî®Á©∫Ê†ºËøûÊé•Ôºâ\n      question.questionText += ' ' + line;\n    }\n  }\n};\n\n/**\n * È™åËØÅÈ¢òÁõÆÊòØÂê¶ÊúâÊïà\n */\nconst isValidQuestion = (question) => {\n  const hasValidType = QUESTION_TYPES.includes(question.questionType);\n  const hasContent = question.questionText && question.questionText.trim().length > 5;\n  \n  if (!hasValidType) {\n    console.warn(`‚ö†Ô∏è Êó†ÊïàÁöÑÈ¢òÁõÆÁ±ªÂûã: ${question.questionType}`);\n  }\n  \n  if (!hasContent) {\n    console.warn(`‚ö†Ô∏è È¢òÁõÆÂÜÖÂÆπËøáÁü≠Êàñ‰∏∫Á©∫: ${question.questionText}`);\n  }\n  \n  return hasValidType && hasContent;\n};\n\n/**\n * Â§ÑÁêÜÈ¢òÁõÆÔºåÊ∑ªÂä†Âü∫Á°Ä‰ø°ÊÅØ\n */\nconst processQuestion = (rawQuestion, baseTags) => {\n  return {\n    questionType: rawQuestion.questionType,\n    questionText: cleanText(rawQuestion.questionText),\n    answer: cleanText(rawQuestion.answer),\n    solutionSteps: cleanText(rawQuestion.solutionSteps),\n    tags: [...baseTags], // ‰ΩøÁî®‰º†ÂÖ•ÁöÑÂü∫Á°ÄÊ†áÁ≠æ\n    createdAt: new Date().toISOString(),\n    metadata: {\n      parsedAt: new Date().toISOString(),\n      startLine: rawQuestion.startLine,\n      originalLength: rawQuestion.questionText.length\n    }\n  };\n};\n\n/**\n * Ê∏ÖÁêÜÊñáÊú¨ÂÜÖÂÆπ\n */\nconst cleanText = (text) => {\n  if (!text || typeof text !== 'string') return '';\n  \n  return text\n    .trim()                          // ÂéªÈô§È¶ñÂ∞æÁ©∫Ê†º\n    .replace(/\\*+/g, '')            // ÂéªÈô§MarkdownÁ≤ó‰ΩìÊ†áËÆ∞\n    .replace(/_{2,}/g, '')          // ÂéªÈô§‰∏ãÂàíÁ∫ø\n    .replace(/\\s+/g, ' ')           // ÂêàÂπ∂Â§ö‰∏™Á©∫Ê†º\n    .replace(/\\n\\s*\\n/g, '\\n')      // ÂêàÂπ∂Â§ö‰∏™Êç¢Ë°å\n    .trim();\n};\n\n/**\n * È™åËØÅËß£ÊûêÁªìÊûú\n */\nexport const validateParseResult = (questions) => {\n  const validation = {\n    isValid: true,\n    totalQuestions: questions.length,\n    issues: [],\n    statistics: {\n      byType: {},\n      averageLength: 0,\n      withAnswers: 0,\n      withSolutions: 0\n    }\n  };\n\n  let totalLength = 0;\n\n  questions.forEach((question, index) => {\n    // ÁªüËÆ°È¢òÁõÆÁ±ªÂûã\n    validation.statistics.byType[question.questionType] = \n      (validation.statistics.byType[question.questionType] || 0) + 1;\n\n    // ÁªüËÆ°ÈïøÂ∫¶\n    totalLength += question.questionText.length;\n\n    // ÁªüËÆ°Á≠îÊ°àÂíåËß£È¢òÊÄùË∑Ø\n    if (question.answer && question.answer.trim()) {\n      validation.statistics.withAnswers++;\n    }\n    \n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      validation.statistics.withSolutions++;\n    }\n\n    // Ê£ÄÊü•ÈóÆÈ¢ò\n    if (question.questionText.length < 10) {\n      validation.issues.push(`È¢òÁõÆ ${index + 1} ÂÜÖÂÆπËøáÁü≠`);\n    }\n    \n    if (!question.answer || !question.answer.trim()) {\n      validation.issues.push(`È¢òÁõÆ ${index + 1} Áº∫Â∞ëÁ≠îÊ°à`);\n    }\n    \n    if (question.tags.length === 0) {\n      validation.issues.push(`È¢òÁõÆ ${index + 1} Áº∫Â∞ëÊ†áÁ≠æ`);\n    }\n  });\n\n  validation.statistics.averageLength = questions.length > 0 \n    ? Math.round(totalLength / questions.length) \n    : 0;\n\n  validation.isValid = validation.issues.length === 0;\n\n  return validation;\n};\n\n/**\n * ÁîüÊàêËß£ÊûêÊä•Âëä\n */\nexport const generateParseReport = (questions, originalText) => {\n  const validation = validateParseResult(questions);\n  \n  const report = {\n    timestamp: new Date().toISOString(),\n    input: {\n      originalLength: originalText.length,\n      lineCount: originalText.split('\\n').length\n    },\n    output: {\n      questionCount: questions.length,\n      successRate: questions.length > 0 ? '100%' : '0%'\n    },\n    validation,\n    recommendations: []\n  };\n\n  // ÁîüÊàêÂª∫ËÆÆ\n  if (validation.statistics.withAnswers < questions.length) {\n    report.recommendations.push('Âª∫ËÆÆ‰∏∫ÊâÄÊúâÈ¢òÁõÆÊ∑ªÂä†Ê†áÂáÜÁ≠îÊ°à');\n  }\n  \n  if (validation.statistics.withSolutions < questions.length * 0.8) {\n    report.recommendations.push('Âª∫ËÆÆ‰∏∫Êõ¥Â§öÈ¢òÁõÆÊ∑ªÂä†Ëß£È¢òÊÄùË∑Ø');\n  }\n  \n  if (validation.issues.length > 0) {\n    report.recommendations.push('ËØ∑Ê£ÄÊü•Âπ∂‰øÆÂ§çÂèëÁé∞ÁöÑÈóÆÈ¢ò');\n  }\n\n  return report;\n};\n\n/**\n * ÂØºÂá∫Ëß£ÊûêÁªüËÆ°\n */\nexport const getParseStatistics = (questions) => {\n  const stats = {\n    total: questions.length,\n    byType: {},\n    byCategory: {},\n    quality: {\n      withAnswers: 0,\n      withSolutions: 0,\n      averageTextLength: 0,\n      averageAnswerLength: 0\n    }\n  };\n\n  let totalTextLength = 0;\n  let totalAnswerLength = 0;\n\n  questions.forEach(question => {\n    // ÊåâÁ±ªÂûãÁªüËÆ°\n    stats.byType[question.questionType] = (stats.byType[question.questionType] || 0) + 1;\n\n    // ÊåâÂàÜÁ±ªÁªüËÆ°\n    const categories = question.tags.filter(tag => \n      ['ËÆ°ÁÆó', 'ËÆ°Êï∞', 'Âá†‰Ωï', 'Êï∞ËÆ∫', 'Â∫îÁî®È¢ò', 'Ë°åÁ®ã', 'ÁªÑÂêà'].includes(tag)\n    );\n    categories.forEach(category => {\n      stats.byCategory[category] = (stats.byCategory[category] || 0) + 1;\n    });\n\n    // Ë¥®ÈáèÁªüËÆ°\n    totalTextLength += question.questionText.length;\n    if (question.answer) {\n      stats.quality.withAnswers++;\n      totalAnswerLength += question.answer.length;\n    }\n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      stats.quality.withSolutions++;\n    }\n  });\n\n  stats.quality.averageTextLength = questions.length > 0 \n    ? Math.round(totalTextLength / questions.length) \n    : 0;\n  \n  stats.quality.averageAnswerLength = stats.quality.withAnswers > 0 \n    ? Math.round(totalAnswerLength / stats.quality.withAnswers)\n    : 0;\n\n  return stats;\n};\n\n/**\n * Ê£ÄÊµãÈáçÂ§çÈ¢òÁõÆ\n */\nexport const detectDuplicates = (newQuestions, existingQuestions) => {\n  const duplicates = [];\n  const uniqueQuestions = [];\n\n  newQuestions.forEach((newQ, index) => {\n    const isExisting = existingQuestions.some(existingQ => \n      isSimilarQuestion(newQ, existingQ)\n    );\n    \n    const isDuplicateInBatch = uniqueQuestions.some(uniqueQ => \n      isSimilarQuestion(newQ, uniqueQ)\n    );\n\n    if (isExisting || isDuplicateInBatch) {\n      duplicates.push({\n        index,\n        question: newQ,\n        reason: isExisting ? 'exists_in_database' : 'duplicate_in_batch'\n      });\n    } else {\n      uniqueQuestions.push(newQ);\n    }\n  });\n\n  return {\n    duplicates,\n    uniqueQuestions,\n    duplicateCount: duplicates.length,\n    uniqueCount: uniqueQuestions.length\n  };\n};\n\n/**\n * Âà§Êñ≠‰∏§‰∏™È¢òÁõÆÊòØÂê¶Áõ∏‰ºº\n */\nconst isSimilarQuestion = (q1, q2) => {\n  // ÁÆÄÂçïÁöÑÁõ∏‰ººÂ∫¶Ê£ÄÊµãÔºöÊØîËæÉÈ¢òÁõÆÂºÄÂ§¥30‰∏™Â≠óÁ¨¶\n  const text1 = q1.questionText.substring(0, 30).replace(/\\s+/g, '');\n  const text2 = q2.questionText.substring(0, 30).replace(/\\s+/g, '');\n  \n  return text1 === text2;\n};\n\n/**\n * È¢ÑÂ§ÑÁêÜMarkdownÊñáÊ°£\n */\nexport const preprocessMarkdown = (markdownText) => {\n  if (!markdownText || typeof markdownText !== 'string') {\n    return '';\n  }\n\n  return markdownText\n    // Áªü‰∏ÄÊç¢Ë°åÁ¨¶\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '\\n')\n    \n    // Ê∏ÖÁêÜÂ§ö‰ΩôÁöÑÁ©∫Ë°å\n    .replace(/\\n{3,}/g, '\\n\\n')\n    \n    // Áªü‰∏ÄÊ†áÈ¢òÊ†ºÂºè\n    .replace(/^#+\\s*/gm, '## ')\n    \n    // Ê∏ÖÁêÜË°åÈ¶ñÁ©∫Ê†º\n    .replace(/^\\s+/gm, '')\n    \n    // Ê∏ÖÁêÜË°åÂ∞æÁ©∫Ê†º\n    .replace(/\\s+$/gm, '')\n    \n    .trim();\n};\n\n/**\n * ÊèêÂèñÊñáÊ°£ÂÖÉ‰ø°ÊÅØ\n */\nexport const extractDocumentMeta = (markdownText) => {\n  const meta = {\n    hasQuestions: false,\n    questionCount: 0,\n    hasAnswers: false,\n    hasSolutions: false,\n    estimatedProcessingTime: 0,\n    detectedPatterns: []\n  };\n\n  if (!markdownText) return meta;\n\n  // Ê£ÄÊµãÈ¢òÁõÆÊ®°Âºè\n  MARKDOWN_PATTERNS.questionPatterns.forEach((pattern, index) => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasQuestions = true;\n      meta.questionCount = Math.max(meta.questionCount, matches.length);\n      meta.detectedPatterns.push({\n        pattern: index,\n        matches: matches.length,\n        examples: matches.slice(0, 3)\n      });\n    }\n  });\n\n  // Ê£ÄÊµãÁ≠îÊ°à\n  MARKDOWN_PATTERNS.answerPatterns.forEach(pattern => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasAnswers = true;\n    }\n  });\n\n  // Ê£ÄÊµãËß£È¢òÊÄùË∑Ø\n  meta.hasSolutions = MARKDOWN_PATTERNS.solutionKeywords.some(keyword => \n    markdownText.includes(keyword)\n  );\n\n  // ‰º∞ÁÆóÂ§ÑÁêÜÊó∂Èó¥ÔºàÊØ´ÁßíÔºâ\n  meta.estimatedProcessingTime = Math.max(100, markdownText.length / 100);\n\n  return meta;\n};\n\n/**\n * ‰øÆÂ§çÂ∏∏ËßÅÁöÑÊ†ºÂºèÈóÆÈ¢ò\n */\nexport const fixCommonFormatIssues = (markdownText) => {\n  return markdownText\n    // ‰øÆÂ§çÈ¢òÁõÆÁºñÂè∑Ê†ºÂºè\n    .replace(/‰æã(\\d+)[\\.ÔºéÔºö:]/g, '‰æã$1. ')\n    .replace(/‰π†È¢ò(\\d+)[\\.ÔºéÔºö:]/g, '‰π†È¢ò$1. ')\n    \n    // ‰øÆÂ§çÁ≠îÊ°àÊ†ºÂºè\n    .replace(/Á≠îÊ°à[Ôºö:]\\s*/g, 'Á≠îÊ°à: ')\n    .replace(/ÊúÄÁªàÁ≠îÊ°à[Ôºö:]\\s*/g, 'ÊúÄÁªàÁ≠îÊ°à: ')\n    \n    // ‰øÆÂ§çÊ†áÈ¢òÊ†ºÂºè\n    .replace(/^([‰æã‰π†]\\d+[\\.ÔºéÔºö:].*)/gm, '## $1')\n    \n    // ‰øÆÂ§çËß£È¢òÊÄùË∑ØÊ†ºÂºè\n    .replace(/Ëß£È¢òÊÄùË∑Ø[Ôºö:]?\\s*/g, '### Ëß£È¢òÊÄùË∑Ø\\n')\n    \n    // ‰øÆÂ§ç‰∏≠ÊñáÊ†áÁÇπ\n    .replace(/Ôºå\\s*/g, 'Ôºå')\n    .replace(/„ÄÇ\\s*/g, '„ÄÇ')\n    .replace(/Ôºõ\\s*/g, 'Ôºõ')\n    \n    // Ê∏ÖÁêÜÂ§ö‰ΩôÁ©∫Ê†º\n    .replace(/\\s+/g, ' ')\n    .replace(/\\n\\s+/g, '\\n');\n};\n\n/**\n * Êô∫ËÉΩÂàÜÊÆµÂ§ÑÁêÜ\n */\nexport const intelligentSegmentation = (markdownText) => {\n  const segments = [];\n  const lines = markdownText.split('\\n');\n  let currentSegment = [];\n  let segmentType = 'unknown';\n\n  lines.forEach(line => {\n    const trimmedLine = line.trim();\n    \n    if (!trimmedLine) {\n      if (currentSegment.length > 0) {\n        currentSegment.push('');\n      }\n      return;\n    }\n\n    // Ê£ÄÊµãÊñ∞ÁöÑÈ¢òÁõÆÊÆµËêΩ\n    const isQuestionStart = matchQuestionPattern(trimmedLine);\n    if (isQuestionStart) {\n      // ‰øùÂ≠òÂΩìÂâçÊÆµËêΩ\n      if (currentSegment.length > 0) {\n        segments.push({\n          type: segmentType,\n          content: currentSegment.join('\\n'),\n          lineCount: currentSegment.length\n        });\n      }\n      \n      // ÂºÄÂßãÊñ∞ÊÆµËêΩ\n      currentSegment = [trimmedLine];\n      segmentType = 'question';\n      return;\n    }\n\n    // Ê∑ªÂä†Âà∞ÂΩìÂâçÊÆµËêΩ\n    currentSegment.push(trimmedLine);\n  });\n\n  // ‰øùÂ≠òÊúÄÂêé‰∏Ä‰∏™ÊÆµËêΩ\n  if (currentSegment.length > 0) {\n    segments.push({\n      type: segmentType,\n      content: currentSegment.join('\\n'),\n      lineCount: currentSegment.length\n    });\n  }\n\n  return segments;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}