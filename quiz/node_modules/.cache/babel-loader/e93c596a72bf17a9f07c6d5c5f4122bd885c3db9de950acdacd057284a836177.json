{"ast":null,"code":"// src/utils/markdownParser.js\n// Markdown解析引擎 - 专门解析AI生成的题目文档\n\nimport { MARKDOWN_PATTERNS, QUESTION_TYPES } from './constants.js';\n\n/**\n * 解析Markdown文档，提取题目信息\n * @param {string} markdownText - Markdown文档内容\n * @param {string[]} baseTags - 基础标签（课程信息）\n * @returns {Object[]} - 解析出的题目数组\n */\nexport const parseMarkdownQuestions = (markdownText, baseTags = []) => {\n  console.log('📖 开始解析Markdown文档');\n  console.log('📝 文档长度:', markdownText.length);\n  console.log('🏷️ 基础标签:', baseTags);\n  if (!markdownText || typeof markdownText !== 'string') {\n    console.warn('❌ 输入文档为空或格式错误');\n    return [];\n  }\n  const lines = markdownText.split('\\n');\n  const questions = [];\n  let currentQuestion = null;\n  let currentSection = 'question'; // question, solution, answer\n  let lineNumber = 0;\n  console.log(`📄 总行数: ${lines.length}`);\n  for (const line of lines) {\n    lineNumber++;\n    const trimmedLine = line.trim();\n\n    // 跳过空行\n    if (!trimmedLine) continue;\n\n    // 检查是否是新题目开始\n    const questionMatch = matchQuestionPattern(trimmedLine);\n    if (questionMatch) {\n      // 保存上一道题目\n      if (currentQuestion && isValidQuestion(currentQuestion)) {\n        const processedQuestion = processQuestion(currentQuestion, baseTags);\n        questions.push(processedQuestion);\n        console.log(`✅ 完成题目: ${processedQuestion.questionType}`);\n      }\n\n      // 开始新题目\n      console.log(`🆕 发现新题目: ${questionMatch.type} (行 ${lineNumber})`);\n      currentQuestion = {\n        questionType: questionMatch.type,\n        questionText: questionMatch.content || '',\n        answer: '',\n        solutionSteps: '',\n        rawLine: trimmedLine,\n        startLine: lineNumber\n      };\n      currentSection = 'question';\n      continue;\n    }\n\n    // 如果没有当前题目，跳过这行\n    if (!currentQuestion) continue;\n\n    // 检查解题思路标识\n    if (isSolutionSection(trimmedLine)) {\n      console.log(`💡 进入解题思路部分 (行 ${lineNumber})`);\n      currentSection = 'solution';\n      continue;\n    }\n\n    // 检查答案标识\n    const answerMatch = matchAnswerPattern(trimmedLine);\n    if (answerMatch) {\n      console.log(`✅ 找到答案 (行 ${lineNumber}): ${answerMatch.substring(0, 50)}...`);\n      currentQuestion.answer = answerMatch;\n      continue;\n    }\n\n    // 处理普通内容行\n    if (isContentLine(trimmedLine)) {\n      processContentLine(currentQuestion, trimmedLine, currentSection);\n    }\n  }\n\n  // 处理最后一道题目\n  if (currentQuestion && isValidQuestion(currentQuestion)) {\n    const processedQuestion = processQuestion(currentQuestion, baseTags);\n    questions.push(processedQuestion);\n    console.log(`✅ 完成最后一题: ${processedQuestion.questionType}`);\n  }\n  console.log(`🎉 解析完成! 共解析出 ${questions.length} 道题目`);\n  return questions;\n};\n\n/**\n * 匹配题目模式\n */\nconst matchQuestionPattern = line => {\n  for (const pattern of MARKDOWN_PATTERNS.questionPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return {\n        type: match[1],\n        // 例1, 习题1等\n        content: match[2] || '',\n        // 题目内容\n        fullMatch: match[0]\n      };\n    }\n  }\n  return null;\n};\n\n/**\n * 匹配答案模式\n */\nconst matchAnswerPattern = line => {\n  for (const pattern of MARKDOWN_PATTERNS.answerPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return match[1].replace(/\\*+/g, '').trim();\n    }\n  }\n  return null;\n};\n\n/**\n * 检查是否是解题思路部分\n */\nconst isSolutionSection = line => {\n  return MARKDOWN_PATTERNS.solutionKeywords.some(keyword => line.includes(keyword));\n};\n\n/**\n * 检查是否是有效的内容行\n */\nconst isContentLine = line => {\n  // 排除Markdown标记行\n  const excludePatterns = [/^#+\\s/,\n  // 标题行\n  /^-{3,}$/,\n  // 分隔线\n  /^\\*{3,}$/,\n  // 分隔线\n  /^={3,}$/,\n  // 分隔线\n  /^\\s*$/ // 空行\n  ];\n  return !excludePatterns.some(pattern => pattern.test(line)) && line.length > 2;\n};\n\n/**\n * 处理内容行\n */\nconst processContentLine = (question, line, section) => {\n  if (section === 'solution') {\n    question.solutionSteps += line + '\\n';\n  } else if (section === 'question') {\n    // 如果题目文字为空，这是第一行\n    if (!question.questionText || question.questionText.trim() === '') {\n      question.questionText = line;\n    } else {\n      // 否则追加到题目内容（用空格连接）\n      question.questionText += ' ' + line;\n    }\n  }\n};\n\n/**\n * 验证题目是否有效\n */\nconst isValidQuestion = question => {\n  const hasValidType = QUESTION_TYPES.includes(question.questionType);\n  const hasContent = question.questionText && question.questionText.trim().length > 5;\n  if (!hasValidType) {\n    console.warn(`⚠️ 无效的题目类型: ${question.questionType}`);\n  }\n  if (!hasContent) {\n    console.warn(`⚠️ 题目内容过短或为空: ${question.questionText}`);\n  }\n  return hasValidType && hasContent;\n};\n\n/**\n * 处理题目，添加基础信息\n */\nconst processQuestion = (rawQuestion, baseTags) => {\n  return {\n    questionType: rawQuestion.questionType,\n    questionText: cleanText(rawQuestion.questionText),\n    answer: cleanText(rawQuestion.answer),\n    solutionSteps: cleanText(rawQuestion.solutionSteps),\n    tags: [...baseTags],\n    // 使用传入的基础标签\n    createdAt: new Date().toISOString(),\n    metadata: {\n      parsedAt: new Date().toISOString(),\n      startLine: rawQuestion.startLine,\n      originalLength: rawQuestion.questionText.length\n    }\n  };\n};\n\n/**\n * 清理文本内容\n */\nconst cleanText = text => {\n  if (!text || typeof text !== 'string') return '';\n  return text.trim() // 去除首尾空格\n  .replace(/\\*+/g, '') // 去除Markdown粗体标记\n  .replace(/_{2,}/g, '') // 去除下划线\n  .replace(/\\s+/g, ' ') // 合并多个空格\n  .replace(/\\n\\s*\\n/g, '\\n') // 合并多个换行\n  .trim();\n};\n\n/**\n * 验证解析结果\n */\nexport const validateParseResult = questions => {\n  const validation = {\n    isValid: true,\n    totalQuestions: questions.length,\n    issues: [],\n    statistics: {\n      byType: {},\n      averageLength: 0,\n      withAnswers: 0,\n      withSolutions: 0\n    }\n  };\n  let totalLength = 0;\n  questions.forEach((question, index) => {\n    // 统计题目类型\n    validation.statistics.byType[question.questionType] = (validation.statistics.byType[question.questionType] || 0) + 1;\n\n    // 统计长度\n    totalLength += question.questionText.length;\n\n    // 统计答案和解题思路\n    if (question.answer && question.answer.trim()) {\n      validation.statistics.withAnswers++;\n    }\n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      validation.statistics.withSolutions++;\n    }\n\n    // 检查问题\n    if (question.questionText.length < 10) {\n      validation.issues.push(`题目 ${index + 1} 内容过短`);\n    }\n    if (!question.answer || !question.answer.trim()) {\n      validation.issues.push(`题目 ${index + 1} 缺少答案`);\n    }\n    if (question.tags.length === 0) {\n      validation.issues.push(`题目 ${index + 1} 缺少标签`);\n    }\n  });\n  validation.statistics.averageLength = questions.length > 0 ? Math.round(totalLength / questions.length) : 0;\n  validation.isValid = validation.issues.length === 0;\n  return validation;\n};\n\n/**\n * 生成解析报告\n */\nexport const generateParseReport = (questions, originalText) => {\n  const validation = validateParseResult(questions);\n  const report = {\n    timestamp: new Date().toISOString(),\n    input: {\n      originalLength: originalText.length,\n      lineCount: originalText.split('\\n').length\n    },\n    output: {\n      questionCount: questions.length,\n      successRate: questions.length > 0 ? '100%' : '0%'\n    },\n    validation,\n    recommendations: []\n  };\n\n  // 生成建议\n  if (validation.statistics.withAnswers < questions.length) {\n    report.recommendations.push('建议为所有题目添加标准答案');\n  }\n  if (validation.statistics.withSolutions < questions.length * 0.8) {\n    report.recommendations.push('建议为更多题目添加解题思路');\n  }\n  if (validation.issues.length > 0) {\n    report.recommendations.push('请检查并修复发现的问题');\n  }\n  return report;\n};\n\n/**\n * 导出解析统计\n */\nexport const getParseStatistics = questions => {\n  const stats = {\n    total: questions.length,\n    byType: {},\n    byCategory: {},\n    quality: {\n      withAnswers: 0,\n      withSolutions: 0,\n      averageTextLength: 0,\n      averageAnswerLength: 0\n    }\n  };\n  let totalTextLength = 0;\n  let totalAnswerLength = 0;\n  questions.forEach(question => {\n    // 按类型统计\n    stats.byType[question.questionType] = (stats.byType[question.questionType] || 0) + 1;\n\n    // 按分类统计\n    const categories = question.tags.filter(tag => ['计算', '计数', '几何', '数论', '应用题', '行程', '组合'].includes(tag));\n    categories.forEach(category => {\n      stats.byCategory[category] = (stats.byCategory[category] || 0) + 1;\n    });\n\n    // 质量统计\n    totalTextLength += question.questionText.length;\n    if (question.answer) {\n      stats.quality.withAnswers++;\n      totalAnswerLength += question.answer.length;\n    }\n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      stats.quality.withSolutions++;\n    }\n  });\n  stats.quality.averageTextLength = questions.length > 0 ? Math.round(totalTextLength / questions.length) : 0;\n  stats.quality.averageAnswerLength = stats.quality.withAnswers > 0 ? Math.round(totalAnswerLength / stats.quality.withAnswers) : 0;\n  return stats;\n};\n\n/**\n * 检测重复题目\n */\nexport const detectDuplicates = (newQuestions, existingQuestions) => {\n  const duplicates = [];\n  const uniqueQuestions = [];\n  newQuestions.forEach((newQ, index) => {\n    const isExisting = existingQuestions.some(existingQ => isSimilarQuestion(newQ, existingQ));\n    const isDuplicateInBatch = uniqueQuestions.some(uniqueQ => isSimilarQuestion(newQ, uniqueQ));\n    if (isExisting || isDuplicateInBatch) {\n      duplicates.push({\n        index,\n        question: newQ,\n        reason: isExisting ? 'exists_in_database' : 'duplicate_in_batch'\n      });\n    } else {\n      uniqueQuestions.push(newQ);\n    }\n  });\n  return {\n    duplicates,\n    uniqueQuestions,\n    duplicateCount: duplicates.length,\n    uniqueCount: uniqueQuestions.length\n  };\n};\n\n/**\n * 判断两个题目是否相似\n */\nconst isSimilarQuestion = (q1, q2) => {\n  // 简单的相似度检测：比较题目开头30个字符\n  const text1 = q1.questionText.substring(0, 30).replace(/\\s+/g, '');\n  const text2 = q2.questionText.substring(0, 30).replace(/\\s+/g, '');\n  return text1 === text2;\n};\n\n/**\n * 预处理Markdown文档\n */\nexport const preprocessMarkdown = markdownText => {\n  if (!markdownText || typeof markdownText !== 'string') {\n    return '';\n  }\n  return markdownText\n  // 统一换行符\n  .replace(/\\r\\n/g, '\\n').replace(/\\r/g, '\\n')\n\n  // 清理多余的空行\n  .replace(/\\n{3,}/g, '\\n\\n')\n\n  // 统一标题格式\n  .replace(/^#+\\s*/gm, '## ')\n\n  // 清理行首空格\n  .replace(/^\\s+/gm, '')\n\n  // 清理行尾空格\n  .replace(/\\s+$/gm, '').trim();\n};\n\n/**\n * 提取文档元信息\n */\nexport const extractDocumentMeta = markdownText => {\n  const meta = {\n    hasQuestions: false,\n    questionCount: 0,\n    hasAnswers: false,\n    hasSolutions: false,\n    estimatedProcessingTime: 0,\n    detectedPatterns: []\n  };\n  if (!markdownText) return meta;\n\n  // 检测题目模式\n  MARKDOWN_PATTERNS.questionPatterns.forEach((pattern, index) => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasQuestions = true;\n      meta.questionCount = Math.max(meta.questionCount, matches.length);\n      meta.detectedPatterns.push({\n        pattern: index,\n        matches: matches.length,\n        examples: matches.slice(0, 3)\n      });\n    }\n  });\n\n  // 检测答案\n  MARKDOWN_PATTERNS.answerPatterns.forEach(pattern => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasAnswers = true;\n    }\n  });\n\n  // 检测解题思路\n  meta.hasSolutions = MARKDOWN_PATTERNS.solutionKeywords.some(keyword => markdownText.includes(keyword));\n\n  // 估算处理时间（毫秒）\n  meta.estimatedProcessingTime = Math.max(100, markdownText.length / 100);\n  return meta;\n};\n\n/**\n * 修复常见的格式问题\n */\nexport const fixCommonFormatIssues = markdownText => {\n  return markdownText\n  // 修复题目编号格式\n  .replace(/例(\\d+)[\\.．：:]/g, '例$1. ').replace(/习题(\\d+)[\\.．：:]/g, '习题$1. ')\n\n  // 修复答案格式\n  .replace(/答案[：:]\\s*/g, '答案: ').replace(/最终答案[：:]\\s*/g, '最终答案: ')\n\n  // 修复标题格式\n  .replace(/^([例习]\\d+[\\.．：:].*)/gm, '## $1')\n\n  // 修复解题思路格式\n  .replace(/解题思路[：:]?\\s*/g, '### 解题思路\\n')\n\n  // 修复中文标点\n  .replace(/，\\s*/g, '，').replace(/。\\s*/g, '。').replace(/；\\s*/g, '；')\n\n  // 清理多余空格\n  .replace(/\\s+/g, ' ').replace(/\\n\\s+/g, '\\n');\n};\n\n/**\n * 智能分段处理\n */\nexport const intelligentSegmentation = markdownText => {\n  const segments = [];\n  const lines = markdownText.split('\\n');\n  let currentSegment = [];\n  let segmentType = 'unknown';\n  lines.forEach(line => {\n    const trimmedLine = line.trim();\n    if (!trimmedLine) {\n      if (currentSegment.length > 0) {\n        currentSegment.push('');\n      }\n      return;\n    }\n\n    // 检测新的题目段落\n    const isQuestionStart = matchQuestionPattern(trimmedLine);\n    if (isQuestionStart) {\n      // 保存当前段落\n      if (currentSegment.length > 0) {\n        segments.push({\n          type: segmentType,\n          content: currentSegment.join('\\n'),\n          lineCount: currentSegment.length\n        });\n      }\n\n      // 开始新段落\n      currentSegment = [trimmedLine];\n      segmentType = 'question';\n      return;\n    }\n\n    // 添加到当前段落\n    currentSegment.push(trimmedLine);\n  });\n\n  // 保存最后一个段落\n  if (currentSegment.length > 0) {\n    segments.push({\n      type: segmentType,\n      content: currentSegment.join('\\n'),\n      lineCount: currentSegment.length\n    });\n  }\n  return segments;\n};","map":{"version":3,"names":["MARKDOWN_PATTERNS","QUESTION_TYPES","parseMarkdownQuestions","markdownText","baseTags","console","log","length","warn","lines","split","questions","currentQuestion","currentSection","lineNumber","line","trimmedLine","trim","questionMatch","matchQuestionPattern","isValidQuestion","processedQuestion","processQuestion","push","questionType","type","questionText","content","answer","solutionSteps","rawLine","startLine","isSolutionSection","answerMatch","matchAnswerPattern","substring","isContentLine","processContentLine","pattern","questionPatterns","match","fullMatch","answerPatterns","replace","solutionKeywords","some","keyword","includes","excludePatterns","test","question","section","hasValidType","hasContent","rawQuestion","cleanText","tags","createdAt","Date","toISOString","metadata","parsedAt","originalLength","text","validateParseResult","validation","isValid","totalQuestions","issues","statistics","byType","averageLength","withAnswers","withSolutions","totalLength","forEach","index","Math","round","generateParseReport","originalText","report","timestamp","input","lineCount","output","questionCount","successRate","recommendations","getParseStatistics","stats","total","byCategory","quality","averageTextLength","averageAnswerLength","totalTextLength","totalAnswerLength","categories","filter","tag","category","detectDuplicates","newQuestions","existingQuestions","duplicates","uniqueQuestions","newQ","isExisting","existingQ","isSimilarQuestion","isDuplicateInBatch","uniqueQ","reason","duplicateCount","uniqueCount","q1","q2","text1","text2","preprocessMarkdown","extractDocumentMeta","meta","hasQuestions","hasAnswers","hasSolutions","estimatedProcessingTime","detectedPatterns","matches","RegExp","source","max","examples","slice","fixCommonFormatIssues","intelligentSegmentation","segments","currentSegment","segmentType","isQuestionStart","join"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/quiz/src/utils/markdownParser.js"],"sourcesContent":["// src/utils/markdownParser.js\n// Markdown解析引擎 - 专门解析AI生成的题目文档\n\nimport { MARKDOWN_PATTERNS, QUESTION_TYPES } from './constants.js';\n\n/**\n * 解析Markdown文档，提取题目信息\n * @param {string} markdownText - Markdown文档内容\n * @param {string[]} baseTags - 基础标签（课程信息）\n * @returns {Object[]} - 解析出的题目数组\n */\nexport const parseMarkdownQuestions = (markdownText, baseTags = []) => {\n  console.log('📖 开始解析Markdown文档');\n  console.log('📝 文档长度:', markdownText.length);\n  console.log('🏷️ 基础标签:', baseTags);\n\n  if (!markdownText || typeof markdownText !== 'string') {\n    console.warn('❌ 输入文档为空或格式错误');\n    return [];\n  }\n\n  const lines = markdownText.split('\\n');\n  const questions = [];\n  \n  let currentQuestion = null;\n  let currentSection = 'question'; // question, solution, answer\n  let lineNumber = 0;\n\n  console.log(`📄 总行数: ${lines.length}`);\n\n  for (const line of lines) {\n    lineNumber++;\n    const trimmedLine = line.trim();\n    \n    // 跳过空行\n    if (!trimmedLine) continue;\n\n    // 检查是否是新题目开始\n    const questionMatch = matchQuestionPattern(trimmedLine);\n    \n    if (questionMatch) {\n      // 保存上一道题目\n      if (currentQuestion && isValidQuestion(currentQuestion)) {\n        const processedQuestion = processQuestion(currentQuestion, baseTags);\n        questions.push(processedQuestion);\n        console.log(`✅ 完成题目: ${processedQuestion.questionType}`);\n      }\n\n      // 开始新题目\n      console.log(`🆕 发现新题目: ${questionMatch.type} (行 ${lineNumber})`);\n      currentQuestion = {\n        questionType: questionMatch.type,\n        questionText: questionMatch.content || '',\n        answer: '',\n        solutionSteps: '',\n        rawLine: trimmedLine,\n        startLine: lineNumber\n      };\n      currentSection = 'question';\n      continue;\n    }\n\n    // 如果没有当前题目，跳过这行\n    if (!currentQuestion) continue;\n\n    // 检查解题思路标识\n    if (isSolutionSection(trimmedLine)) {\n      console.log(`💡 进入解题思路部分 (行 ${lineNumber})`);\n      currentSection = 'solution';\n      continue;\n    }\n\n    // 检查答案标识\n    const answerMatch = matchAnswerPattern(trimmedLine);\n    if (answerMatch) {\n      console.log(`✅ 找到答案 (行 ${lineNumber}): ${answerMatch.substring(0, 50)}...`);\n      currentQuestion.answer = answerMatch;\n      continue;\n    }\n\n    // 处理普通内容行\n    if (isContentLine(trimmedLine)) {\n      processContentLine(currentQuestion, trimmedLine, currentSection);\n    }\n  }\n\n  // 处理最后一道题目\n  if (currentQuestion && isValidQuestion(currentQuestion)) {\n    const processedQuestion = processQuestion(currentQuestion, baseTags);\n    questions.push(processedQuestion);\n    console.log(`✅ 完成最后一题: ${processedQuestion.questionType}`);\n  }\n\n  console.log(`🎉 解析完成! 共解析出 ${questions.length} 道题目`);\n  return questions;\n};\n\n/**\n * 匹配题目模式\n */\nconst matchQuestionPattern = (line) => {\n  for (const pattern of MARKDOWN_PATTERNS.questionPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return {\n        type: match[1],           // 例1, 习题1等\n        content: match[2] || '',  // 题目内容\n        fullMatch: match[0]\n      };\n    }\n  }\n  return null;\n};\n\n/**\n * 匹配答案模式\n */\nconst matchAnswerPattern = (line) => {\n  for (const pattern of MARKDOWN_PATTERNS.answerPatterns) {\n    const match = line.match(pattern);\n    if (match) {\n      return match[1].replace(/\\*+/g, '').trim();\n    }\n  }\n  return null;\n};\n\n/**\n * 检查是否是解题思路部分\n */\nconst isSolutionSection = (line) => {\n  return MARKDOWN_PATTERNS.solutionKeywords.some(keyword => \n    line.includes(keyword)\n  );\n};\n\n/**\n * 检查是否是有效的内容行\n */\nconst isContentLine = (line) => {\n  // 排除Markdown标记行\n  const excludePatterns = [\n    /^#+\\s/,           // 标题行\n    /^-{3,}$/,         // 分隔线\n    /^\\*{3,}$/,        // 分隔线\n    /^={3,}$/,         // 分隔线\n    /^\\s*$/            // 空行\n  ];\n\n  return !excludePatterns.some(pattern => pattern.test(line)) && \n         line.length > 2;\n};\n\n/**\n * 处理内容行\n */\nconst processContentLine = (question, line, section) => {\n  if (section === 'solution') {\n    question.solutionSteps += line + '\\n';\n  } else if (section === 'question') {\n    // 如果题目文字为空，这是第一行\n    if (!question.questionText || question.questionText.trim() === '') {\n      question.questionText = line;\n    } else {\n      // 否则追加到题目内容（用空格连接）\n      question.questionText += ' ' + line;\n    }\n  }\n};\n\n/**\n * 验证题目是否有效\n */\nconst isValidQuestion = (question) => {\n  const hasValidType = QUESTION_TYPES.includes(question.questionType);\n  const hasContent = question.questionText && question.questionText.trim().length > 5;\n  \n  if (!hasValidType) {\n    console.warn(`⚠️ 无效的题目类型: ${question.questionType}`);\n  }\n  \n  if (!hasContent) {\n    console.warn(`⚠️ 题目内容过短或为空: ${question.questionText}`);\n  }\n  \n  return hasValidType && hasContent;\n};\n\n/**\n * 处理题目，添加基础信息\n */\nconst processQuestion = (rawQuestion, baseTags) => {\n  return {\n    questionType: rawQuestion.questionType,\n    questionText: cleanText(rawQuestion.questionText),\n    answer: cleanText(rawQuestion.answer),\n    solutionSteps: cleanText(rawQuestion.solutionSteps),\n    tags: [...baseTags], // 使用传入的基础标签\n    createdAt: new Date().toISOString(),\n    metadata: {\n      parsedAt: new Date().toISOString(),\n      startLine: rawQuestion.startLine,\n      originalLength: rawQuestion.questionText.length\n    }\n  };\n};\n\n/**\n * 清理文本内容\n */\nconst cleanText = (text) => {\n  if (!text || typeof text !== 'string') return '';\n  \n  return text\n    .trim()                          // 去除首尾空格\n    .replace(/\\*+/g, '')            // 去除Markdown粗体标记\n    .replace(/_{2,}/g, '')          // 去除下划线\n    .replace(/\\s+/g, ' ')           // 合并多个空格\n    .replace(/\\n\\s*\\n/g, '\\n')      // 合并多个换行\n    .trim();\n};\n\n/**\n * 验证解析结果\n */\nexport const validateParseResult = (questions) => {\n  const validation = {\n    isValid: true,\n    totalQuestions: questions.length,\n    issues: [],\n    statistics: {\n      byType: {},\n      averageLength: 0,\n      withAnswers: 0,\n      withSolutions: 0\n    }\n  };\n\n  let totalLength = 0;\n\n  questions.forEach((question, index) => {\n    // 统计题目类型\n    validation.statistics.byType[question.questionType] = \n      (validation.statistics.byType[question.questionType] || 0) + 1;\n\n    // 统计长度\n    totalLength += question.questionText.length;\n\n    // 统计答案和解题思路\n    if (question.answer && question.answer.trim()) {\n      validation.statistics.withAnswers++;\n    }\n    \n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      validation.statistics.withSolutions++;\n    }\n\n    // 检查问题\n    if (question.questionText.length < 10) {\n      validation.issues.push(`题目 ${index + 1} 内容过短`);\n    }\n    \n    if (!question.answer || !question.answer.trim()) {\n      validation.issues.push(`题目 ${index + 1} 缺少答案`);\n    }\n    \n    if (question.tags.length === 0) {\n      validation.issues.push(`题目 ${index + 1} 缺少标签`);\n    }\n  });\n\n  validation.statistics.averageLength = questions.length > 0 \n    ? Math.round(totalLength / questions.length) \n    : 0;\n\n  validation.isValid = validation.issues.length === 0;\n\n  return validation;\n};\n\n/**\n * 生成解析报告\n */\nexport const generateParseReport = (questions, originalText) => {\n  const validation = validateParseResult(questions);\n  \n  const report = {\n    timestamp: new Date().toISOString(),\n    input: {\n      originalLength: originalText.length,\n      lineCount: originalText.split('\\n').length\n    },\n    output: {\n      questionCount: questions.length,\n      successRate: questions.length > 0 ? '100%' : '0%'\n    },\n    validation,\n    recommendations: []\n  };\n\n  // 生成建议\n  if (validation.statistics.withAnswers < questions.length) {\n    report.recommendations.push('建议为所有题目添加标准答案');\n  }\n  \n  if (validation.statistics.withSolutions < questions.length * 0.8) {\n    report.recommendations.push('建议为更多题目添加解题思路');\n  }\n  \n  if (validation.issues.length > 0) {\n    report.recommendations.push('请检查并修复发现的问题');\n  }\n\n  return report;\n};\n\n/**\n * 导出解析统计\n */\nexport const getParseStatistics = (questions) => {\n  const stats = {\n    total: questions.length,\n    byType: {},\n    byCategory: {},\n    quality: {\n      withAnswers: 0,\n      withSolutions: 0,\n      averageTextLength: 0,\n      averageAnswerLength: 0\n    }\n  };\n\n  let totalTextLength = 0;\n  let totalAnswerLength = 0;\n\n  questions.forEach(question => {\n    // 按类型统计\n    stats.byType[question.questionType] = (stats.byType[question.questionType] || 0) + 1;\n\n    // 按分类统计\n    const categories = question.tags.filter(tag => \n      ['计算', '计数', '几何', '数论', '应用题', '行程', '组合'].includes(tag)\n    );\n    categories.forEach(category => {\n      stats.byCategory[category] = (stats.byCategory[category] || 0) + 1;\n    });\n\n    // 质量统计\n    totalTextLength += question.questionText.length;\n    if (question.answer) {\n      stats.quality.withAnswers++;\n      totalAnswerLength += question.answer.length;\n    }\n    if (question.solutionSteps && question.solutionSteps.trim()) {\n      stats.quality.withSolutions++;\n    }\n  });\n\n  stats.quality.averageTextLength = questions.length > 0 \n    ? Math.round(totalTextLength / questions.length) \n    : 0;\n  \n  stats.quality.averageAnswerLength = stats.quality.withAnswers > 0 \n    ? Math.round(totalAnswerLength / stats.quality.withAnswers)\n    : 0;\n\n  return stats;\n};\n\n/**\n * 检测重复题目\n */\nexport const detectDuplicates = (newQuestions, existingQuestions) => {\n  const duplicates = [];\n  const uniqueQuestions = [];\n\n  newQuestions.forEach((newQ, index) => {\n    const isExisting = existingQuestions.some(existingQ => \n      isSimilarQuestion(newQ, existingQ)\n    );\n    \n    const isDuplicateInBatch = uniqueQuestions.some(uniqueQ => \n      isSimilarQuestion(newQ, uniqueQ)\n    );\n\n    if (isExisting || isDuplicateInBatch) {\n      duplicates.push({\n        index,\n        question: newQ,\n        reason: isExisting ? 'exists_in_database' : 'duplicate_in_batch'\n      });\n    } else {\n      uniqueQuestions.push(newQ);\n    }\n  });\n\n  return {\n    duplicates,\n    uniqueQuestions,\n    duplicateCount: duplicates.length,\n    uniqueCount: uniqueQuestions.length\n  };\n};\n\n/**\n * 判断两个题目是否相似\n */\nconst isSimilarQuestion = (q1, q2) => {\n  // 简单的相似度检测：比较题目开头30个字符\n  const text1 = q1.questionText.substring(0, 30).replace(/\\s+/g, '');\n  const text2 = q2.questionText.substring(0, 30).replace(/\\s+/g, '');\n  \n  return text1 === text2;\n};\n\n/**\n * 预处理Markdown文档\n */\nexport const preprocessMarkdown = (markdownText) => {\n  if (!markdownText || typeof markdownText !== 'string') {\n    return '';\n  }\n\n  return markdownText\n    // 统一换行符\n    .replace(/\\r\\n/g, '\\n')\n    .replace(/\\r/g, '\\n')\n    \n    // 清理多余的空行\n    .replace(/\\n{3,}/g, '\\n\\n')\n    \n    // 统一标题格式\n    .replace(/^#+\\s*/gm, '## ')\n    \n    // 清理行首空格\n    .replace(/^\\s+/gm, '')\n    \n    // 清理行尾空格\n    .replace(/\\s+$/gm, '')\n    \n    .trim();\n};\n\n/**\n * 提取文档元信息\n */\nexport const extractDocumentMeta = (markdownText) => {\n  const meta = {\n    hasQuestions: false,\n    questionCount: 0,\n    hasAnswers: false,\n    hasSolutions: false,\n    estimatedProcessingTime: 0,\n    detectedPatterns: []\n  };\n\n  if (!markdownText) return meta;\n\n  // 检测题目模式\n  MARKDOWN_PATTERNS.questionPatterns.forEach((pattern, index) => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasQuestions = true;\n      meta.questionCount = Math.max(meta.questionCount, matches.length);\n      meta.detectedPatterns.push({\n        pattern: index,\n        matches: matches.length,\n        examples: matches.slice(0, 3)\n      });\n    }\n  });\n\n  // 检测答案\n  MARKDOWN_PATTERNS.answerPatterns.forEach(pattern => {\n    const matches = markdownText.match(new RegExp(pattern.source, 'gm'));\n    if (matches && matches.length > 0) {\n      meta.hasAnswers = true;\n    }\n  });\n\n  // 检测解题思路\n  meta.hasSolutions = MARKDOWN_PATTERNS.solutionKeywords.some(keyword => \n    markdownText.includes(keyword)\n  );\n\n  // 估算处理时间（毫秒）\n  meta.estimatedProcessingTime = Math.max(100, markdownText.length / 100);\n\n  return meta;\n};\n\n/**\n * 修复常见的格式问题\n */\nexport const fixCommonFormatIssues = (markdownText) => {\n  return markdownText\n    // 修复题目编号格式\n    .replace(/例(\\d+)[\\.．：:]/g, '例$1. ')\n    .replace(/习题(\\d+)[\\.．：:]/g, '习题$1. ')\n    \n    // 修复答案格式\n    .replace(/答案[：:]\\s*/g, '答案: ')\n    .replace(/最终答案[：:]\\s*/g, '最终答案: ')\n    \n    // 修复标题格式\n    .replace(/^([例习]\\d+[\\.．：:].*)/gm, '## $1')\n    \n    // 修复解题思路格式\n    .replace(/解题思路[：:]?\\s*/g, '### 解题思路\\n')\n    \n    // 修复中文标点\n    .replace(/，\\s*/g, '，')\n    .replace(/。\\s*/g, '。')\n    .replace(/；\\s*/g, '；')\n    \n    // 清理多余空格\n    .replace(/\\s+/g, ' ')\n    .replace(/\\n\\s+/g, '\\n');\n};\n\n/**\n * 智能分段处理\n */\nexport const intelligentSegmentation = (markdownText) => {\n  const segments = [];\n  const lines = markdownText.split('\\n');\n  let currentSegment = [];\n  let segmentType = 'unknown';\n\n  lines.forEach(line => {\n    const trimmedLine = line.trim();\n    \n    if (!trimmedLine) {\n      if (currentSegment.length > 0) {\n        currentSegment.push('');\n      }\n      return;\n    }\n\n    // 检测新的题目段落\n    const isQuestionStart = matchQuestionPattern(trimmedLine);\n    if (isQuestionStart) {\n      // 保存当前段落\n      if (currentSegment.length > 0) {\n        segments.push({\n          type: segmentType,\n          content: currentSegment.join('\\n'),\n          lineCount: currentSegment.length\n        });\n      }\n      \n      // 开始新段落\n      currentSegment = [trimmedLine];\n      segmentType = 'question';\n      return;\n    }\n\n    // 添加到当前段落\n    currentSegment.push(trimmedLine);\n  });\n\n  // 保存最后一个段落\n  if (currentSegment.length > 0) {\n    segments.push({\n      type: segmentType,\n      content: currentSegment.join('\\n'),\n      lineCount: currentSegment.length\n    });\n  }\n\n  return segments;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}