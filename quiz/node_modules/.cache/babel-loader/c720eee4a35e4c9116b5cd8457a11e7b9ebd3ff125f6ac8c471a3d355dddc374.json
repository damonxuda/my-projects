{"ast":null,"code":"import{supportsLocalStorage}from'./helpers';/**\n * @experimental\n */export const internals={/**\n     * @experimental\n     */debug:!!(globalThis&&supportsLocalStorage()&&globalThis.localStorage&&globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug')==='true')};/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */export class LockAcquireTimeoutError extends Error{constructor(message){super(message);this.isAcquireTimeout=true;}}export class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError{}export class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError{}/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */export async function navigatorLock(name,acquireTimeout,fn){if(internals.debug){console.log('@supabase/gotrue-js: navigatorLock: acquire lock',name,acquireTimeout);}const abortController=new globalThis.AbortController();if(acquireTimeout>0){setTimeout(()=>{abortController.abort();if(internals.debug){console.log('@supabase/gotrue-js: navigatorLock acquire timed out',name);}},acquireTimeout);}// MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n// Wrapping navigator.locks.request() with a plain Promise is done as some\n// libraries like zone.js patch the Promise object to track the execution\n// context. However, it appears that most browsers use an internal promise\n// implementation when using the navigator.locks.request() API causing them\n// to lose context and emit confusing log messages or break certain features.\n// This wrapping is believed to help zone.js track the execution context\n// better.\nreturn await Promise.resolve().then(()=>globalThis.navigator.locks.request(name,acquireTimeout===0?{mode:'exclusive',ifAvailable:true}:{mode:'exclusive',signal:abortController.signal},async lock=>{if(lock){if(internals.debug){console.log('@supabase/gotrue-js: navigatorLock: acquired',name,lock.name);}try{return await fn();}finally{if(internals.debug){console.log('@supabase/gotrue-js: navigatorLock: released',name,lock.name);}}}else{if(acquireTimeout===0){if(internals.debug){console.log('@supabase/gotrue-js: navigatorLock: not immediately available',name);}throw new NavigatorLockAcquireTimeoutError(`Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`);}else{if(internals.debug){try{const result=await globalThis.navigator.locks.query();console.log('@supabase/gotrue-js: Navigator LockManager state',JSON.stringify(result,null,'  '));}catch(e){console.warn('@supabase/gotrue-js: Error when querying Navigator LockManager state',e);}}// Browser is not following the Navigator LockManager spec, it\n// returned a null lock when we didn't use ifAvailable. So we can\n// pretend the lock is acquired in the name of backward compatibility\n// and user experience and just run the function.\nconsole.warn('@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request');return await fn();}}}));}const PROCESS_LOCKS={};/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */export async function processLock(name,acquireTimeout,fn){var _a;const previousOperation=(_a=PROCESS_LOCKS[name])!==null&&_a!==void 0?_a:Promise.resolve();const currentOperation=Promise.race([previousOperation.catch(()=>{// ignore error of previous operation that we're waiting to finish\nreturn null;}),acquireTimeout>=0?new Promise((_,reject)=>{setTimeout(()=>{reject(new ProcessLockAcquireTimeoutError(`Acquring process lock with name \"${name}\" timed out`));},acquireTimeout);}):null].filter(x=>x)).catch(e=>{if(e&&e.isAcquireTimeout){throw e;}return null;}).then(async()=>{// previous operations finished and we didn't get a race on the acquire\n// timeout, so the current operation can finally start\nreturn await fn();});PROCESS_LOCKS[name]=currentOperation.catch(async e=>{if(e&&e.isAcquireTimeout){// if the current operation timed out, it doesn't mean that the previous\n// operation finished, so we need contnue waiting for it to finish\nawait previousOperation;return null;}throw e;});// finally wait for the current operation to finish successfully, with an\n// error or with an acquire timeout error\nreturn await currentOperation;}","map":{"version":3,"names":["supportsLocalStorage","internals","debug","globalThis","localStorage","getItem","LockAcquireTimeoutError","Error","constructor","message","isAcquireTimeout","NavigatorLockAcquireTimeoutError","ProcessLockAcquireTimeoutError","navigatorLock","name","acquireTimeout","fn","console","log","abortController","AbortController","setTimeout","abort","Promise","resolve","then","navigator","locks","request","mode","ifAvailable","signal","lock","result","query","JSON","stringify","e","warn","PROCESS_LOCKS","processLock","previousOperation","_a","currentOperation","race","catch","_","reject","filter","x"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/auth-js/src/lib/locks.ts"],"sourcesContent":["import { supportsLocalStorage } from './helpers'\n\n/**\n * @experimental\n */\nexport const internals = {\n  /**\n   * @experimental\n   */\n  debug: !!(\n    globalThis &&\n    supportsLocalStorage() &&\n    globalThis.localStorage &&\n    globalThis.localStorage.getItem('supabase.gotrue-js.locks.debug') === 'true'\n  ),\n}\n\n/**\n * An error thrown when a lock cannot be acquired after some amount of time.\n *\n * Use the {@link #isAcquireTimeout} property instead of checking with `instanceof`.\n */\nexport abstract class LockAcquireTimeoutError extends Error {\n  public readonly isAcquireTimeout = true\n\n  constructor(message: string) {\n    super(message)\n  }\n}\n\nexport class NavigatorLockAcquireTimeoutError extends LockAcquireTimeoutError {}\nexport class ProcessLockAcquireTimeoutError extends LockAcquireTimeoutError {}\n\n/**\n * Implements a global exclusive lock using the Navigator LockManager API. It\n * is available on all browsers released after 2022-03-15 with Safari being the\n * last one to release support. If the API is not available, this function will\n * throw. Make sure you check availablility before configuring {@link\n * GoTrueClient}.\n *\n * You can turn on debugging by setting the `supabase.gotrue-js.locks.debug`\n * local storage item to `true`.\n *\n * Internals:\n *\n * Since the LockManager API does not preserve stack traces for the async\n * function passed in the `request` method, a trick is used where acquiring the\n * lock releases a previously started promise to run the operation in the `fn`\n * function. The lock waits for that promise to finish (with or without error),\n * while the function will finally wait for the result anyway.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function navigatorLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  if (internals.debug) {\n    console.log('@supabase/gotrue-js: navigatorLock: acquire lock', name, acquireTimeout)\n  }\n\n  const abortController = new globalThis.AbortController()\n\n  if (acquireTimeout > 0) {\n    setTimeout(() => {\n      abortController.abort()\n      if (internals.debug) {\n        console.log('@supabase/gotrue-js: navigatorLock acquire timed out', name)\n      }\n    }, acquireTimeout)\n  }\n\n  // MDN article: https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n\n  // Wrapping navigator.locks.request() with a plain Promise is done as some\n  // libraries like zone.js patch the Promise object to track the execution\n  // context. However, it appears that most browsers use an internal promise\n  // implementation when using the navigator.locks.request() API causing them\n  // to lose context and emit confusing log messages or break certain features.\n  // This wrapping is believed to help zone.js track the execution context\n  // better.\n  return await Promise.resolve().then(() =>\n    globalThis.navigator.locks.request(\n      name,\n      acquireTimeout === 0\n        ? {\n            mode: 'exclusive',\n            ifAvailable: true,\n          }\n        : {\n            mode: 'exclusive',\n            signal: abortController.signal,\n          },\n      async (lock) => {\n        if (lock) {\n          if (internals.debug) {\n            console.log('@supabase/gotrue-js: navigatorLock: acquired', name, lock.name)\n          }\n\n          try {\n            return await fn()\n          } finally {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: released', name, lock.name)\n            }\n          }\n        } else {\n          if (acquireTimeout === 0) {\n            if (internals.debug) {\n              console.log('@supabase/gotrue-js: navigatorLock: not immediately available', name)\n            }\n\n            throw new NavigatorLockAcquireTimeoutError(\n              `Acquiring an exclusive Navigator LockManager lock \"${name}\" immediately failed`\n            )\n          } else {\n            if (internals.debug) {\n              try {\n                const result = await globalThis.navigator.locks.query()\n\n                console.log(\n                  '@supabase/gotrue-js: Navigator LockManager state',\n                  JSON.stringify(result, null, '  ')\n                )\n              } catch (e: any) {\n                console.warn(\n                  '@supabase/gotrue-js: Error when querying Navigator LockManager state',\n                  e\n                )\n              }\n            }\n\n            // Browser is not following the Navigator LockManager spec, it\n            // returned a null lock when we didn't use ifAvailable. So we can\n            // pretend the lock is acquired in the name of backward compatibility\n            // and user experience and just run the function.\n            console.warn(\n              '@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request'\n            )\n\n            return await fn()\n          }\n        }\n      }\n    )\n  )\n}\n\nconst PROCESS_LOCKS: { [name: string]: Promise<any> } = {}\n\n/**\n * Implements a global exclusive lock that works only in the current process.\n * Useful for environments like React Native or other non-browser\n * single-process (i.e. no concept of \"tabs\") environments.\n *\n * Use {@link #navigatorLock} in browser environments.\n *\n * @param name Name of the lock to be acquired.\n * @param acquireTimeout If negative, no timeout. If 0 an error is thrown if\n *                       the lock can't be acquired without waiting. If positive, the lock acquire\n *                       will time out after so many milliseconds. An error is\n *                       a timeout if it has `isAcquireTimeout` set to true.\n * @param fn The operation to run once the lock is acquired.\n */\nexport async function processLock<R>(\n  name: string,\n  acquireTimeout: number,\n  fn: () => Promise<R>\n): Promise<R> {\n  const previousOperation = PROCESS_LOCKS[name] ?? Promise.resolve()\n\n  const currentOperation = Promise.race(\n    [\n      previousOperation.catch(() => {\n        // ignore error of previous operation that we're waiting to finish\n        return null\n      }),\n      acquireTimeout >= 0\n        ? new Promise((_, reject) => {\n            setTimeout(() => {\n              reject(\n                new ProcessLockAcquireTimeoutError(\n                  `Acquring process lock with name \"${name}\" timed out`\n                )\n              )\n            }, acquireTimeout)\n          })\n        : null,\n    ].filter((x) => x)\n  )\n    .catch((e: any) => {\n      if (e && e.isAcquireTimeout) {\n        throw e\n      }\n\n      return null\n    })\n    .then(async () => {\n      // previous operations finished and we didn't get a race on the acquire\n      // timeout, so the current operation can finally start\n      return await fn()\n    })\n\n  PROCESS_LOCKS[name] = currentOperation.catch(async (e: any) => {\n    if (e && e.isAcquireTimeout) {\n      // if the current operation timed out, it doesn't mean that the previous\n      // operation finished, so we need contnue waiting for it to finish\n      await previousOperation\n\n      return null\n    }\n\n    throw e\n  })\n\n  // finally wait for the current operation to finish successfully, with an\n  // error or with an acquire timeout error\n  return await currentOperation\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}