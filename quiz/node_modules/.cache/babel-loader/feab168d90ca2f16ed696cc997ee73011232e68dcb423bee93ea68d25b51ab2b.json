{"ast":null,"code":"/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n *//**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */const TO_BASE64URL='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */const IGNORE_BASE64URL=' \\t\\n\\r='.split('');/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */const FROM_BASE64URL=(()=>{const charMap=new Array(128);for(let i=0;i<charMap.length;i+=1){charMap[i]=-1;}for(let i=0;i<IGNORE_BASE64URL.length;i+=1){charMap[IGNORE_BASE64URL[i].charCodeAt(0)]=-2;}for(let i=0;i<TO_BASE64URL.length;i+=1){charMap[TO_BASE64URL[i].charCodeAt(0)]=i;}return charMap;})();/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */export function byteToBase64URL(byte,state,emit){if(byte!==null){state.queue=state.queue<<8|byte;state.queuedBits+=8;while(state.queuedBits>=6){const pos=state.queue>>state.queuedBits-6&63;emit(TO_BASE64URL[pos]);state.queuedBits-=6;}}else if(state.queuedBits>0){state.queue=state.queue<<6-state.queuedBits;state.queuedBits=6;while(state.queuedBits>=6){const pos=state.queue>>state.queuedBits-6&63;emit(TO_BASE64URL[pos]);state.queuedBits-=6;}}}/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */export function byteFromBase64URL(charCode,state,emit){const bits=FROM_BASE64URL[charCode];if(bits>-1){// valid Base64-URL character\nstate.queue=state.queue<<6|bits;state.queuedBits+=6;while(state.queuedBits>=8){emit(state.queue>>state.queuedBits-8&0xff);state.queuedBits-=8;}}else if(bits===-2){// ignore spaces, tabs, newlines, =\nreturn;}else{throw new Error(\"Invalid Base64-URL character \\\"\".concat(String.fromCharCode(charCode),\"\\\"\"));}}/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */export function stringToBase64URL(str){const base64=[];const emitter=char=>{base64.push(char);};const state={queue:0,queuedBits:0};stringToUTF8(str,byte=>{byteToBase64URL(byte,state,emitter);});byteToBase64URL(null,state,emitter);return base64.join('');}/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */export function stringFromBase64URL(str){const conv=[];const utf8Emit=codepoint=>{conv.push(String.fromCodePoint(codepoint));};const utf8State={utf8seq:0,codepoint:0};const b64State={queue:0,queuedBits:0};const byteEmit=byte=>{stringFromUTF8(byte,utf8State,utf8Emit);};for(let i=0;i<str.length;i+=1){byteFromBase64URL(str.charCodeAt(i),b64State,byteEmit);}return conv.join('');}/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */export function codepointToUTF8(codepoint,emit){if(codepoint<=0x7f){emit(codepoint);return;}else if(codepoint<=0x7ff){emit(0xc0|codepoint>>6);emit(0x80|codepoint&0x3f);return;}else if(codepoint<=0xffff){emit(0xe0|codepoint>>12);emit(0x80|codepoint>>6&0x3f);emit(0x80|codepoint&0x3f);return;}else if(codepoint<=0x10ffff){emit(0xf0|codepoint>>18);emit(0x80|codepoint>>12&0x3f);emit(0x80|codepoint>>6&0x3f);emit(0x80|codepoint&0x3f);return;}throw new Error(\"Unrecognized Unicode codepoint: \".concat(codepoint.toString(16)));}/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */export function stringToUTF8(str,emit){for(let i=0;i<str.length;i+=1){let codepoint=str.charCodeAt(i);if(codepoint>0xd7ff&&codepoint<=0xdbff){// most UTF-16 codepoints are Unicode codepoints, except values in this\n// range where the next UTF-16 codepoint needs to be combined with the\n// current one to get the Unicode codepoint\nconst highSurrogate=(codepoint-0xd800)*0x400&0xffff;const lowSurrogate=str.charCodeAt(i+1)-0xdc00&0xffff;codepoint=(lowSurrogate|highSurrogate)+0x10000;i+=1;}codepointToUTF8(codepoint,emit);}}/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */export function stringFromUTF8(byte,state,emit){if(state.utf8seq===0){if(byte<=0x7f){emit(byte);return;}// count the number of 1 leading bits until you reach 0\nfor(let leadingBit=1;leadingBit<6;leadingBit+=1){if((byte>>7-leadingBit&1)===0){state.utf8seq=leadingBit;break;}}if(state.utf8seq===2){state.codepoint=byte&31;}else if(state.utf8seq===3){state.codepoint=byte&15;}else if(state.utf8seq===4){state.codepoint=byte&7;}else{throw new Error('Invalid UTF-8 sequence');}state.utf8seq-=1;}else if(state.utf8seq>0){if(byte<=0x7f){throw new Error('Invalid UTF-8 sequence');}state.codepoint=state.codepoint<<6|byte&63;state.utf8seq-=1;if(state.utf8seq===0){emit(state.codepoint);}}}/**\n * Helper functions to convert different types of strings to Uint8Array\n */export function base64UrlToUint8Array(str){const result=[];const state={queue:0,queuedBits:0};const onByte=byte=>{result.push(byte);};for(let i=0;i<str.length;i+=1){byteFromBase64URL(str.charCodeAt(i),state,onByte);}return new Uint8Array(result);}export function stringToUint8Array(str){const result=[];stringToUTF8(str,byte=>result.push(byte));return new Uint8Array(result);}export function bytesToBase64URL(bytes){const result=[];const state={queue:0,queuedBits:0};const onChar=char=>{result.push(char);};bytes.forEach(byte=>byteToBase64URL(byte,state,onChar));// always call with `null` after processing all bytes\nbyteToBase64URL(null,state,onChar);return result.join('');}","map":{"version":3,"names":["TO_BASE64URL","split","IGNORE_BASE64URL","FROM_BASE64URL","charMap","Array","i","length","charCodeAt","byteToBase64URL","byte","state","emit","queue","queuedBits","pos","byteFromBase64URL","charCode","bits","Error","concat","String","fromCharCode","stringToBase64URL","str","base64","emitter","char","push","stringToUTF8","join","stringFromBase64URL","conv","utf8Emit","codepoint","fromCodePoint","utf8State","utf8seq","b64State","byteEmit","stringFromUTF8","codepointToUTF8","toString","highSurrogate","lowSurrogate","leadingBit","base64UrlToUint8Array","result","onByte","Uint8Array","stringToUint8Array","bytesToBase64URL","bytes","onChar","forEach"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/auth-js/src/lib/base64url.ts"],"sourcesContent":["/**\n * Avoid modifying this file. It's part of\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\n * that repo!\n */\n\n/**\n * An array of characters that encode 6 bits into a Base64-URL alphabet\n * character.\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('')\n\n/**\n * An array of characters that can appear in a Base64-URL encoded string but\n * should be ignored.\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('')\n\n/**\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\n * used to skip the character, or if -1 used to error out.\n */\nconst FROM_BASE64URL = (() => {\n  const charMap: number[] = new Array(128)\n\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1\n  }\n\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2\n  }\n\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i\n  }\n\n  return charMap\n})()\n\n/**\n * Converts a byte to a Base64-URL string.\n *\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next Base64 character when ready.\n */\nexport function byteToBase64URL(\n  byte: number | null,\n  state: { queue: number; queuedBits: number },\n  emit: (char: string) => void\n) {\n  if (byte !== null) {\n    state.queue = (state.queue << 8) | byte\n    state.queuedBits += 8\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << (6 - state.queuedBits)\n    state.queuedBits = 6\n\n    while (state.queuedBits >= 6) {\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\n      emit(TO_BASE64URL[pos])\n      state.queuedBits -= 6\n    }\n  }\n}\n\n/**\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\n *\n * @param charCode The char code of the JavaScript string.\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\n * @param emit A function called with the next byte.\n */\nexport function byteFromBase64URL(\n  charCode: number,\n  state: { queue: number; queuedBits: number },\n  emit: (byte: number) => void\n) {\n  const bits = FROM_BASE64URL[charCode]\n\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = (state.queue << 6) | bits\n    state.queuedBits += 6\n\n    while (state.queuedBits >= 8) {\n      emit((state.queue >> (state.queuedBits - 8)) & 0xff)\n      state.queuedBits -= 8\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return\n  } else {\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`)\n  }\n}\n\n/**\n * Converts a JavaScript string (which may include any valid character) into a\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\n * then encoded as Base64-URL.\n *\n * @param str The string to convert.\n */\nexport function stringToBase64URL(str: string) {\n  const base64: string[] = []\n\n  const emitter = (char: string) => {\n    base64.push(char)\n  }\n\n  const state = { queue: 0, queuedBits: 0 }\n\n  stringToUTF8(str, (byte: number) => {\n    byteToBase64URL(byte, state, emitter)\n  })\n\n  byteToBase64URL(null, state, emitter)\n\n  return base64.join('')\n}\n\n/**\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\n * that the underlying string has been encoded as UTF-8.\n *\n * @param str The Base64-URL encoded string.\n */\nexport function stringFromBase64URL(str: string) {\n  const conv: string[] = []\n\n  const utf8Emit = (codepoint: number) => {\n    conv.push(String.fromCodePoint(codepoint))\n  }\n\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0,\n  }\n\n  const b64State = { queue: 0, queuedBits: 0 }\n\n  const byteEmit = (byte: number) => {\n    stringFromUTF8(byte, utf8State, utf8Emit)\n  }\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit)\n  }\n\n  return conv.join('')\n}\n\n/**\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\n *\n * @param codepoint The Unicode codepoint.\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\n */\nexport function codepointToUTF8(codepoint: number, emit: (byte: number) => void) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint)\n    return\n  } else if (codepoint <= 0x7ff) {\n    emit(0xc0 | (codepoint >> 6))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  } else if (codepoint <= 0xffff) {\n    emit(0xe0 | (codepoint >> 12))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  } else if (codepoint <= 0x10ffff) {\n    emit(0xf0 | (codepoint >> 18))\n    emit(0x80 | ((codepoint >> 12) & 0x3f))\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\n    emit(0x80 | (codepoint & 0x3f))\n    return\n  }\n\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)\n}\n\n/**\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\n *\n * @param str  The string to convert to UTF-8.\n * @param emit Function which will be called for each UTF-8 byte of the string.\n */\nexport function stringToUTF8(str: string, emit: (byte: number) => void) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i)\n\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff\n      const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000\n      i += 1\n    }\n\n    codepointToUTF8(codepoint, emit)\n  }\n}\n\n/**\n * Converts a UTF-8 byte to a Unicode codepoint.\n *\n * @param byte  The UTF-8 byte next in the sequence.\n * @param state The shared state between consecutive UTF-8 bytes in the\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\n * @param emit  Function which will be called for each codepoint.\n */\nexport function stringFromUTF8(\n  byte: number,\n  state: { utf8seq: number; codepoint: number },\n  emit: (codepoint: number) => void\n) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte)\n      return\n    }\n\n    // count the number of 1 leading bits until you reach 0\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if (((byte >> (7 - leadingBit)) & 1) === 0) {\n        state.utf8seq = leadingBit\n        break\n      }\n    }\n\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7\n    } else {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.utf8seq -= 1\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence')\n    }\n\n    state.codepoint = (state.codepoint << 6) | (byte & 63)\n    state.utf8seq -= 1\n\n    if (state.utf8seq === 0) {\n      emit(state.codepoint)\n    }\n  }\n}\n\n/**\n * Helper functions to convert different types of strings to Uint8Array\n */\n\nexport function base64UrlToUint8Array(str: string): Uint8Array {\n  const result: number[] = []\n  const state = { queue: 0, queuedBits: 0 }\n\n  const onByte = (byte: number) => {\n    result.push(byte)\n  }\n\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), state, onByte)\n  }\n\n  return new Uint8Array(result)\n}\n\nexport function stringToUint8Array(str: string): Uint8Array {\n  const result: number[] = []\n  stringToUTF8(str, (byte: number) => result.push(byte))\n  return new Uint8Array(result)\n}\n\nexport function bytesToBase64URL(bytes: Uint8Array) {\n  const result: string[] = []\n  const state = { queue: 0, queuedBits: 0 }\n\n  const onChar = (char: string) => {\n    result.push(char)\n  }\n\n  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar))\n\n  // always call with `null` after processing all bytes\n  byteToBase64URL(null, state, onChar)\n\n  return result.join('')\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}