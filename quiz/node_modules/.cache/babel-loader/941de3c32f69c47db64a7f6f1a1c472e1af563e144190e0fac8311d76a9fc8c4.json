{"ast":null,"code":"import{CHANNEL_EVENTS,CHANNEL_STATES,MAX_PUSH_BUFFER_SIZE}from'./lib/constants';import Push from'./lib/push';import Timer from'./lib/timer';import RealtimePresence from'./RealtimePresence';import*as Transformers from'./lib/transformers';import{httpEndpointURL}from'./lib/transformers';export var REALTIME_POSTGRES_CHANGES_LISTEN_EVENT;(function(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT){REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"ALL\"]=\"*\";REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"INSERT\"]=\"INSERT\";REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"UPDATE\"]=\"UPDATE\";REALTIME_POSTGRES_CHANGES_LISTEN_EVENT[\"DELETE\"]=\"DELETE\";})(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT||(REALTIME_POSTGRES_CHANGES_LISTEN_EVENT={}));export var REALTIME_LISTEN_TYPES;(function(REALTIME_LISTEN_TYPES){REALTIME_LISTEN_TYPES[\"BROADCAST\"]=\"broadcast\";REALTIME_LISTEN_TYPES[\"PRESENCE\"]=\"presence\";REALTIME_LISTEN_TYPES[\"POSTGRES_CHANGES\"]=\"postgres_changes\";REALTIME_LISTEN_TYPES[\"SYSTEM\"]=\"system\";})(REALTIME_LISTEN_TYPES||(REALTIME_LISTEN_TYPES={}));export var REALTIME_SUBSCRIBE_STATES;(function(REALTIME_SUBSCRIBE_STATES){REALTIME_SUBSCRIBE_STATES[\"SUBSCRIBED\"]=\"SUBSCRIBED\";REALTIME_SUBSCRIBE_STATES[\"TIMED_OUT\"]=\"TIMED_OUT\";REALTIME_SUBSCRIBE_STATES[\"CLOSED\"]=\"CLOSED\";REALTIME_SUBSCRIBE_STATES[\"CHANNEL_ERROR\"]=\"CHANNEL_ERROR\";})(REALTIME_SUBSCRIBE_STATES||(REALTIME_SUBSCRIBE_STATES={}));export const REALTIME_CHANNEL_STATES=CHANNEL_STATES;/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */export default class RealtimeChannel{constructor(/** Topic name can be any string. */topic){let params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{config:{}};let socket=arguments.length>2?arguments[2]:undefined;this.topic=topic;this.params=params;this.socket=socket;this.bindings={};this.state=CHANNEL_STATES.closed;this.joinedOnce=false;this.pushBuffer=[];this.subTopic=topic.replace(/^realtime:/i,'');this.params.config=Object.assign({broadcast:{ack:false,self:false},presence:{key:'',enabled:false},private:false},params.config);this.timeout=this.socket.timeout;this.joinPush=new Push(this,CHANNEL_EVENTS.join,this.params,this.timeout);this.rejoinTimer=new Timer(()=>this._rejoinUntilConnected(),this.socket.reconnectAfterMs);this.joinPush.receive('ok',()=>{this.state=CHANNEL_STATES.joined;this.rejoinTimer.reset();this.pushBuffer.forEach(pushEvent=>pushEvent.send());this.pushBuffer=[];});this._onClose(()=>{this.rejoinTimer.reset();this.socket.log('channel',`close ${this.topic} ${this._joinRef()}`);this.state=CHANNEL_STATES.closed;this.socket._remove(this);});this._onError(reason=>{if(this._isLeaving()||this._isClosed()){return;}this.socket.log('channel',`error ${this.topic}`,reason);this.state=CHANNEL_STATES.errored;this.rejoinTimer.scheduleTimeout();});this.joinPush.receive('timeout',()=>{if(!this._isJoining()){return;}this.socket.log('channel',`timeout ${this.topic}`,this.joinPush.timeout);this.state=CHANNEL_STATES.errored;this.rejoinTimer.scheduleTimeout();});this.joinPush.receive('error',reason=>{if(this._isLeaving()||this._isClosed()){return;}this.socket.log('channel',`error ${this.topic}`,reason);this.state=CHANNEL_STATES.errored;this.rejoinTimer.scheduleTimeout();});this._on(CHANNEL_EVENTS.reply,{},(payload,ref)=>{this._trigger(this._replyEventName(ref),payload);});this.presence=new RealtimePresence(this);this.broadcastEndpointURL=httpEndpointURL(this.socket.endPoint);this.private=this.params.config.private||false;}/** Subscribe registers your client with the server */subscribe(callback){let timeout=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.timeout;var _a,_b;if(!this.socket.isConnected()){this.socket.connect();}if(this.state==CHANNEL_STATES.closed){const{config:{broadcast,presence,private:isPrivate}}=this.params;const postgres_changes=(_b=(_a=this.bindings.postgres_changes)===null||_a===void 0?void 0:_a.map(r=>r.filter))!==null&&_b!==void 0?_b:[];const presence_enabled=!!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE]&&this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length>0;const accessTokenPayload={};const config={broadcast,presence:Object.assign(Object.assign({},presence),{enabled:presence_enabled}),postgres_changes,private:isPrivate};if(this.socket.accessTokenValue){accessTokenPayload.access_token=this.socket.accessTokenValue;}this._onError(e=>callback===null||callback===void 0?void 0:callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,e));this._onClose(()=>callback===null||callback===void 0?void 0:callback(REALTIME_SUBSCRIBE_STATES.CLOSED));this.updateJoinPayload(Object.assign({config},accessTokenPayload));this.joinedOnce=true;this._rejoin(timeout);this.joinPush.receive('ok',async _ref2=>{let{postgres_changes}=_ref2;var _a;this.socket.setAuth();if(postgres_changes===undefined){callback===null||callback===void 0?void 0:callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);return;}else{const clientPostgresBindings=this.bindings.postgres_changes;const bindingsLen=(_a=clientPostgresBindings===null||clientPostgresBindings===void 0?void 0:clientPostgresBindings.length)!==null&&_a!==void 0?_a:0;const newPostgresBindings=[];for(let i=0;i<bindingsLen;i++){const clientPostgresBinding=clientPostgresBindings[i];const{filter:{event,schema,table,filter}}=clientPostgresBinding;const serverPostgresFilter=postgres_changes&&postgres_changes[i];if(serverPostgresFilter&&serverPostgresFilter.event===event&&serverPostgresFilter.schema===schema&&serverPostgresFilter.table===table&&serverPostgresFilter.filter===filter){newPostgresBindings.push(Object.assign(Object.assign({},clientPostgresBinding),{id:serverPostgresFilter.id}));}else{this.unsubscribe();this.state=CHANNEL_STATES.errored;callback===null||callback===void 0?void 0:callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,new Error('mismatch between server and client bindings for postgres changes'));return;}}this.bindings.postgres_changes=newPostgresBindings;callback&&callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED);return;}}).receive('error',error=>{this.state=CHANNEL_STATES.errored;callback===null||callback===void 0?void 0:callback(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,new Error(JSON.stringify(Object.values(error).join(', ')||'error')));return;}).receive('timeout',()=>{callback===null||callback===void 0?void 0:callback(REALTIME_SUBSCRIBE_STATES.TIMED_OUT);return;});}return this;}presenceState(){return this.presence.state;}async track(payload){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return await this.send({type:'presence',event:'track',payload},opts.timeout||this.timeout);}async untrack(){let opts=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};return await this.send({type:'presence',event:'untrack'},opts);}on(type,filter,callback){if(this.state===CHANNEL_STATES.joined&&type===REALTIME_LISTEN_TYPES.PRESENCE){this.socket.log('channel',`resubscribe to ${this.topic} due to change in presence callbacks on joined channel`);this.unsubscribe().then(()=>this.subscribe());}return this._on(type,filter,callback);}/**\n     * Sends a message into the channel.\n     *\n     * @param args Arguments to send to channel\n     * @param args.type The type of event to send\n     * @param args.event The name of the event being sent\n     * @param args.payload Payload to be sent\n     * @param opts Options to be used during the send process\n     */async send(args){let opts=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var _a,_b;if(!this._canPush()&&args.type==='broadcast'){const{event,payload:endpoint_payload}=args;const authorization=this.socket.accessTokenValue?`Bearer ${this.socket.accessTokenValue}`:'';const options={method:'POST',headers:{Authorization:authorization,apikey:this.socket.apiKey?this.socket.apiKey:'','Content-Type':'application/json'},body:JSON.stringify({messages:[{topic:this.subTopic,event,payload:endpoint_payload,private:this.private}]})};try{const response=await this._fetchWithTimeout(this.broadcastEndpointURL,options,(_a=opts.timeout)!==null&&_a!==void 0?_a:this.timeout);await((_b=response.body)===null||_b===void 0?void 0:_b.cancel());return response.ok?'ok':'error';}catch(error){if(error.name==='AbortError'){return'timed out';}else{return'error';}}}else{return new Promise(resolve=>{var _a,_b,_c;const push=this._push(args.type,args,opts.timeout||this.timeout);if(args.type==='broadcast'&&!((_c=(_b=(_a=this.params)===null||_a===void 0?void 0:_a.config)===null||_b===void 0?void 0:_b.broadcast)===null||_c===void 0?void 0:_c.ack)){resolve('ok');}push.receive('ok',()=>resolve('ok'));push.receive('error',()=>resolve('error'));push.receive('timeout',()=>resolve('timed out'));});}}updateJoinPayload(payload){this.joinPush.updatePayload(payload);}/**\n     * Leaves the channel.\n     *\n     * Unsubscribes from server events, and instructs channel to terminate on server.\n     * Triggers onClose() hooks.\n     *\n     * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n     * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n     */unsubscribe(){let timeout=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.timeout;this.state=CHANNEL_STATES.leaving;const onClose=()=>{this.socket.log('channel',`leave ${this.topic}`);this._trigger(CHANNEL_EVENTS.close,'leave',this._joinRef());};this.joinPush.destroy();let leavePush=null;return new Promise(resolve=>{leavePush=new Push(this,CHANNEL_EVENTS.leave,{},timeout);leavePush.receive('ok',()=>{onClose();resolve('ok');}).receive('timeout',()=>{onClose();resolve('timed out');}).receive('error',()=>{resolve('error');});leavePush.send();if(!this._canPush()){leavePush.trigger('ok',{});}}).finally(()=>{leavePush===null||leavePush===void 0?void 0:leavePush.destroy();});}/**\n     * Teardown the channel.\n     *\n     * Destroys and stops related timers.\n     */teardown(){this.pushBuffer.forEach(push=>push.destroy());this.pushBuffer=[];this.rejoinTimer.reset();this.joinPush.destroy();this.state=CHANNEL_STATES.closed;this.bindings={};}/** @internal */async _fetchWithTimeout(url,options,timeout){const controller=new AbortController();const id=setTimeout(()=>controller.abort(),timeout);const response=await this.socket.fetch(url,Object.assign(Object.assign({},options),{signal:controller.signal}));clearTimeout(id);return response;}/** @internal */_push(event,payload){let timeout=arguments.length>2&&arguments[2]!==undefined?arguments[2]:this.timeout;if(!this.joinedOnce){throw`tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;}let pushEvent=new Push(this,event,payload,timeout);if(this._canPush()){pushEvent.send();}else{this._addToPushBuffer(pushEvent);}return pushEvent;}/** @internal */_addToPushBuffer(pushEvent){pushEvent.startTimeout();this.pushBuffer.push(pushEvent);// Enforce buffer size limit\nif(this.pushBuffer.length>MAX_PUSH_BUFFER_SIZE){const removedPush=this.pushBuffer.shift();if(removedPush){removedPush.destroy();this.socket.log('channel',`discarded push due to buffer overflow: ${removedPush.event}`,removedPush.payload);}}}/**\n     * Overridable message hook\n     *\n     * Receives all events for specialized message handling before dispatching to the channel callbacks.\n     * Must return the payload, modified or unmodified.\n     *\n     * @internal\n     */_onMessage(_event,payload,_ref){return payload;}/** @internal */_isMember(topic){return this.topic===topic;}/** @internal */_joinRef(){return this.joinPush.ref;}/** @internal */_trigger(type,payload,ref){var _a,_b;const typeLower=type.toLocaleLowerCase();const{close,error,leave,join}=CHANNEL_EVENTS;const events=[close,error,leave,join];if(ref&&events.indexOf(typeLower)>=0&&ref!==this._joinRef()){return;}let handledPayload=this._onMessage(typeLower,payload,ref);if(payload&&!handledPayload){throw'channel onMessage callbacks must return the payload, modified or unmodified';}if(['insert','update','delete'].includes(typeLower)){(_a=this.bindings.postgres_changes)===null||_a===void 0?void 0:_a.filter(bind=>{var _a,_b,_c;return((_a=bind.filter)===null||_a===void 0?void 0:_a.event)==='*'||((_c=(_b=bind.filter)===null||_b===void 0?void 0:_b.event)===null||_c===void 0?void 0:_c.toLocaleLowerCase())===typeLower;}).map(bind=>bind.callback(handledPayload,ref));}else{(_b=this.bindings[typeLower])===null||_b===void 0?void 0:_b.filter(bind=>{var _a,_b,_c,_d,_e,_f;if(['broadcast','presence','postgres_changes'].includes(typeLower)){if('id'in bind){const bindId=bind.id;const bindEvent=(_a=bind.filter)===null||_a===void 0?void 0:_a.event;return bindId&&((_b=payload.ids)===null||_b===void 0?void 0:_b.includes(bindId))&&(bindEvent==='*'||(bindEvent===null||bindEvent===void 0?void 0:bindEvent.toLocaleLowerCase())===((_c=payload.data)===null||_c===void 0?void 0:_c.type.toLocaleLowerCase()));}else{const bindEvent=(_e=(_d=bind===null||bind===void 0?void 0:bind.filter)===null||_d===void 0?void 0:_d.event)===null||_e===void 0?void 0:_e.toLocaleLowerCase();return bindEvent==='*'||bindEvent===((_f=payload===null||payload===void 0?void 0:payload.event)===null||_f===void 0?void 0:_f.toLocaleLowerCase());}}else{return bind.type.toLocaleLowerCase()===typeLower;}}).map(bind=>{if(typeof handledPayload==='object'&&'ids'in handledPayload){const postgresChanges=handledPayload.data;const{schema,table,commit_timestamp,type,errors}=postgresChanges;const enrichedPayload={schema:schema,table:table,commit_timestamp:commit_timestamp,eventType:type,new:{},old:{},errors:errors};handledPayload=Object.assign(Object.assign({},enrichedPayload),this._getPayloadRecords(postgresChanges));}bind.callback(handledPayload,ref);});}}/** @internal */_isClosed(){return this.state===CHANNEL_STATES.closed;}/** @internal */_isJoined(){return this.state===CHANNEL_STATES.joined;}/** @internal */_isJoining(){return this.state===CHANNEL_STATES.joining;}/** @internal */_isLeaving(){return this.state===CHANNEL_STATES.leaving;}/** @internal */_replyEventName(ref){return`chan_reply_${ref}`;}/** @internal */_on(type,filter,callback){const typeLower=type.toLocaleLowerCase();const binding={type:typeLower,filter:filter,callback:callback};if(this.bindings[typeLower]){this.bindings[typeLower].push(binding);}else{this.bindings[typeLower]=[binding];}return this;}/** @internal */_off(type,filter){const typeLower=type.toLocaleLowerCase();if(this.bindings[typeLower]){this.bindings[typeLower]=this.bindings[typeLower].filter(bind=>{var _a;return!(((_a=bind.type)===null||_a===void 0?void 0:_a.toLocaleLowerCase())===typeLower&&RealtimeChannel.isEqual(bind.filter,filter));});}return this;}/** @internal */static isEqual(obj1,obj2){if(Object.keys(obj1).length!==Object.keys(obj2).length){return false;}for(const k in obj1){if(obj1[k]!==obj2[k]){return false;}}return true;}/** @internal */_rejoinUntilConnected(){this.rejoinTimer.scheduleTimeout();if(this.socket.isConnected()){this._rejoin();}}/**\n     * Registers a callback that will be executed when the channel closes.\n     *\n     * @internal\n     */_onClose(callback){this._on(CHANNEL_EVENTS.close,{},callback);}/**\n     * Registers a callback that will be executed when the channel encounteres an error.\n     *\n     * @internal\n     */_onError(callback){this._on(CHANNEL_EVENTS.error,{},reason=>callback(reason));}/**\n     * Returns `true` if the socket is connected and the channel has been joined.\n     *\n     * @internal\n     */_canPush(){return this.socket.isConnected()&&this._isJoined();}/** @internal */_rejoin(){let timeout=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.timeout;if(this._isLeaving()){return;}this.socket._leaveOpenTopic(this.topic);this.state=CHANNEL_STATES.joining;this.joinPush.resend(timeout);}/** @internal */_getPayloadRecords(payload){const records={new:{},old:{}};if(payload.type==='INSERT'||payload.type==='UPDATE'){records.new=Transformers.convertChangeData(payload.columns,payload.record);}if(payload.type==='UPDATE'||payload.type==='DELETE'){records.old=Transformers.convertChangeData(payload.columns,payload.old_record);}return records;}}","map":{"version":3,"names":["CHANNEL_EVENTS","CHANNEL_STATES","MAX_PUSH_BUFFER_SIZE","Push","Timer","RealtimePresence","Transformers","httpEndpointURL","REALTIME_POSTGRES_CHANGES_LISTEN_EVENT","REALTIME_LISTEN_TYPES","REALTIME_SUBSCRIBE_STATES","REALTIME_CHANNEL_STATES","RealtimeChannel","constructor","topic","params","arguments","length","undefined","config","socket","bindings","state","closed","joinedOnce","pushBuffer","subTopic","replace","Object","assign","broadcast","ack","self","presence","key","enabled","private","timeout","joinPush","join","rejoinTimer","_rejoinUntilConnected","reconnectAfterMs","receive","joined","reset","forEach","pushEvent","send","_onClose","log","_joinRef","_remove","_onError","reason","_isLeaving","_isClosed","errored","scheduleTimeout","_isJoining","_on","reply","payload","ref","_trigger","_replyEventName","broadcastEndpointURL","endPoint","subscribe","callback","isConnected","connect","isPrivate","postgres_changes","_b","_a","map","r","filter","presence_enabled","PRESENCE","accessTokenPayload","accessTokenValue","access_token","e","CHANNEL_ERROR","CLOSED","updateJoinPayload","_rejoin","_ref2","setAuth","SUBSCRIBED","clientPostgresBindings","bindingsLen","newPostgresBindings","i","clientPostgresBinding","event","schema","table","serverPostgresFilter","push","id","unsubscribe","Error","error","JSON","stringify","values","TIMED_OUT","presenceState","track","opts","type","untrack","on","then","args","_canPush","endpoint_payload","authorization","options","method","headers","Authorization","apikey","apiKey","body","messages","response","_fetchWithTimeout","cancel","ok","name","Promise","resolve","_push","_c","updatePayload","leaving","onClose","close","destroy","leavePush","leave","trigger","finally","teardown","url","controller","AbortController","setTimeout","abort","fetch","signal","clearTimeout","_addToPushBuffer","startTimeout","removedPush","shift","_onMessage","_event","_ref","_isMember","typeLower","toLocaleLowerCase","events","indexOf","handledPayload","includes","bind","bindId","bindEvent","ids","data","_e","_d","_f","postgresChanges","commit_timestamp","errors","enrichedPayload","eventType","new","old","_getPayloadRecords","_isJoined","joining","binding","_off","isEqual","obj1","obj2","keys","k","_leaveOpenTopic","resend","records","convertChangeData","columns","record","old_record"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/realtime-js/src/RealtimeChannel.ts"],"sourcesContent":["import {\n  CHANNEL_EVENTS,\n  CHANNEL_STATES,\n  MAX_PUSH_BUFFER_SIZE,\n} from './lib/constants'\nimport Push from './lib/push'\nimport type RealtimeClient from './RealtimeClient'\nimport Timer from './lib/timer'\nimport RealtimePresence, {\n  REALTIME_PRESENCE_LISTEN_EVENTS,\n} from './RealtimePresence'\nimport type {\n  RealtimePresenceJoinPayload,\n  RealtimePresenceLeavePayload,\n  RealtimePresenceState,\n} from './RealtimePresence'\nimport * as Transformers from './lib/transformers'\nimport { httpEndpointURL } from './lib/transformers'\n\nexport type RealtimeChannelOptions = {\n  config: {\n    /**\n     * self option enables client to receive message it broadcast\n     * ack option instructs server to acknowledge that broadcast message was received\n     */\n    broadcast?: { self?: boolean; ack?: boolean }\n    /**\n     * key option is used to track presence payload across clients\n     */\n    presence?: { key?: string; enabled?: boolean }\n    /**\n     * defines if the channel is private or not and if RLS policies will be used to check data\n     */\n    private?: boolean\n  }\n}\n\ntype RealtimePostgresChangesPayloadBase = {\n  schema: string\n  table: string\n  commit_timestamp: string\n  errors: string[]\n}\n\nexport type RealtimePostgresInsertPayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`\n    new: T\n    old: {}\n  }\n\nexport type RealtimePostgresUpdatePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`\n    new: T\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresDeletePayload<T extends { [key: string]: any }> =\n  RealtimePostgresChangesPayloadBase & {\n    eventType: `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`\n    new: {}\n    old: Partial<T>\n  }\n\nexport type RealtimePostgresChangesPayload<T extends { [key: string]: any }> =\n  | RealtimePostgresInsertPayload<T>\n  | RealtimePostgresUpdatePayload<T>\n  | RealtimePostgresDeletePayload<T>\n\nexport type RealtimePostgresChangesFilter<\n  T extends `${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT}`\n> = {\n  /**\n   * The type of database change to listen to.\n   */\n  event: T\n  /**\n   * The database schema to listen to.\n   */\n  schema: string\n  /**\n   * The database table to listen to.\n   */\n  table?: string\n  /**\n   * Receive database changes when filter is matched.\n   */\n  filter?: string\n}\n\nexport type RealtimeChannelSendResponse = 'ok' | 'timed out' | 'error'\n\nexport enum REALTIME_POSTGRES_CHANGES_LISTEN_EVENT {\n  ALL = '*',\n  INSERT = 'INSERT',\n  UPDATE = 'UPDATE',\n  DELETE = 'DELETE',\n}\n\nexport enum REALTIME_LISTEN_TYPES {\n  BROADCAST = 'broadcast',\n  PRESENCE = 'presence',\n  POSTGRES_CHANGES = 'postgres_changes',\n  SYSTEM = 'system',\n}\n\nexport enum REALTIME_SUBSCRIBE_STATES {\n  SUBSCRIBED = 'SUBSCRIBED',\n  TIMED_OUT = 'TIMED_OUT',\n  CLOSED = 'CLOSED',\n  CHANNEL_ERROR = 'CHANNEL_ERROR',\n}\n\nexport const REALTIME_CHANNEL_STATES = CHANNEL_STATES\n\ninterface PostgresChangesFilters {\n  postgres_changes: {\n    id: string\n    event: string\n    schema?: string\n    table?: string\n    filter?: string\n  }[]\n}\n/** A channel is the basic building block of Realtime\n * and narrows the scope of data flow to subscribed clients.\n * You can think of a channel as a chatroom where participants are able to see who's online\n * and send and receive messages.\n */\nexport default class RealtimeChannel {\n  bindings: {\n    [key: string]: {\n      type: string\n      filter: { [key: string]: any }\n      callback: Function\n      id?: string\n    }[]\n  } = {}\n  timeout: number\n  state: CHANNEL_STATES = CHANNEL_STATES.closed\n  joinedOnce = false\n  joinPush: Push\n  rejoinTimer: Timer\n  pushBuffer: Push[] = []\n  presence: RealtimePresence\n  broadcastEndpointURL: string\n  subTopic: string\n  private: boolean\n\n  constructor(\n    /** Topic name can be any string. */\n    public topic: string,\n    public params: RealtimeChannelOptions = { config: {} },\n    public socket: RealtimeClient\n  ) {\n    this.subTopic = topic.replace(/^realtime:/i, '')\n    this.params.config = {\n      ...{\n        broadcast: { ack: false, self: false },\n        presence: { key: '', enabled: false },\n        private: false,\n      },\n      ...params.config,\n    }\n    this.timeout = this.socket.timeout\n    this.joinPush = new Push(\n      this,\n      CHANNEL_EVENTS.join,\n      this.params,\n      this.timeout\n    )\n    this.rejoinTimer = new Timer(\n      () => this._rejoinUntilConnected(),\n      this.socket.reconnectAfterMs\n    )\n    this.joinPush.receive('ok', () => {\n      this.state = CHANNEL_STATES.joined\n      this.rejoinTimer.reset()\n      this.pushBuffer.forEach((pushEvent: Push) => pushEvent.send())\n      this.pushBuffer = []\n    })\n    this._onClose(() => {\n      this.rejoinTimer.reset()\n      this.socket.log('channel', `close ${this.topic} ${this._joinRef()}`)\n      this.state = CHANNEL_STATES.closed\n      this.socket._remove(this)\n    })\n    this._onError((reason: string) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this.joinPush.receive('timeout', () => {\n      if (!this._isJoining()) {\n        return\n      }\n      this.socket.log('channel', `timeout ${this.topic}`, this.joinPush.timeout)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n\n    this.joinPush.receive('error', (reason: any) => {\n      if (this._isLeaving() || this._isClosed()) {\n        return\n      }\n      this.socket.log('channel', `error ${this.topic}`, reason)\n      this.state = CHANNEL_STATES.errored\n      this.rejoinTimer.scheduleTimeout()\n    })\n    this._on(CHANNEL_EVENTS.reply, {}, (payload: any, ref: string) => {\n      this._trigger(this._replyEventName(ref), payload)\n    })\n\n    this.presence = new RealtimePresence(this)\n\n    this.broadcastEndpointURL = httpEndpointURL(this.socket.endPoint)\n    this.private = this.params.config.private || false\n  }\n\n  /** Subscribe registers your client with the server */\n  subscribe(\n    callback?: (status: REALTIME_SUBSCRIBE_STATES, err?: Error) => void,\n    timeout = this.timeout\n  ): RealtimeChannel {\n    if (!this.socket.isConnected()) {\n      this.socket.connect()\n    }\n    if (this.state == CHANNEL_STATES.closed) {\n      const {\n        config: { broadcast, presence, private: isPrivate },\n      } = this.params\n\n      const postgres_changes =\n        this.bindings.postgres_changes?.map((r) => r.filter) ?? []\n\n      const presence_enabled =\n        !!this.bindings[REALTIME_LISTEN_TYPES.PRESENCE] &&\n        this.bindings[REALTIME_LISTEN_TYPES.PRESENCE].length > 0\n      const accessTokenPayload: { access_token?: string } = {}\n      const config = {\n        broadcast,\n        presence: { ...presence, enabled: presence_enabled },\n        postgres_changes,\n        private: isPrivate,\n      }\n\n      if (this.socket.accessTokenValue) {\n        accessTokenPayload.access_token = this.socket.accessTokenValue\n      }\n\n      this._onError((e: Error) =>\n        callback?.(REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR, e)\n      )\n\n      this._onClose(() => callback?.(REALTIME_SUBSCRIBE_STATES.CLOSED))\n\n      this.updateJoinPayload({ ...{ config }, ...accessTokenPayload })\n\n      this.joinedOnce = true\n      this._rejoin(timeout)\n\n      this.joinPush\n        .receive('ok', async ({ postgres_changes }: PostgresChangesFilters) => {\n          this.socket.setAuth()\n          if (postgres_changes === undefined) {\n            callback?.(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          } else {\n            const clientPostgresBindings = this.bindings.postgres_changes\n            const bindingsLen = clientPostgresBindings?.length ?? 0\n            const newPostgresBindings = []\n\n            for (let i = 0; i < bindingsLen; i++) {\n              const clientPostgresBinding = clientPostgresBindings[i]\n              const {\n                filter: { event, schema, table, filter },\n              } = clientPostgresBinding\n              const serverPostgresFilter =\n                postgres_changes && postgres_changes[i]\n\n              if (\n                serverPostgresFilter &&\n                serverPostgresFilter.event === event &&\n                serverPostgresFilter.schema === schema &&\n                serverPostgresFilter.table === table &&\n                serverPostgresFilter.filter === filter\n              ) {\n                newPostgresBindings.push({\n                  ...clientPostgresBinding,\n                  id: serverPostgresFilter.id,\n                })\n              } else {\n                this.unsubscribe()\n                this.state = CHANNEL_STATES.errored\n\n                callback?.(\n                  REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n                  new Error(\n                    'mismatch between server and client bindings for postgres changes'\n                  )\n                )\n                return\n              }\n            }\n\n            this.bindings.postgres_changes = newPostgresBindings\n\n            callback && callback(REALTIME_SUBSCRIBE_STATES.SUBSCRIBED)\n            return\n          }\n        })\n        .receive('error', (error: { [key: string]: any }) => {\n          this.state = CHANNEL_STATES.errored\n          callback?.(\n            REALTIME_SUBSCRIBE_STATES.CHANNEL_ERROR,\n            new Error(\n              JSON.stringify(Object.values(error).join(', ') || 'error')\n            )\n          )\n          return\n        })\n        .receive('timeout', () => {\n          callback?.(REALTIME_SUBSCRIBE_STATES.TIMED_OUT)\n          return\n        })\n    }\n    return this\n  }\n\n  presenceState<\n    T extends { [key: string]: any } = {}\n  >(): RealtimePresenceState<T> {\n    return this.presence.state as RealtimePresenceState<T>\n  }\n\n  async track(\n    payload: { [key: string]: any },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'track',\n        payload,\n      },\n      opts.timeout || this.timeout\n    )\n  }\n\n  async untrack(\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    return await this.send(\n      {\n        type: 'presence',\n        event: 'untrack',\n      },\n      opts\n    )\n  }\n\n  /**\n   * Creates an event handler that listens to changes.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.SYNC}` },\n    callback: () => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.JOIN}` },\n    callback: (payload: RealtimePresenceJoinPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.PRESENCE}`,\n    filter: { event: `${REALTIME_PRESENCE_LISTEN_EVENTS.LEAVE}` },\n    callback: (payload: RealtimePresenceLeavePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.ALL}`>,\n    callback: (payload: RealtimePostgresChangesPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.INSERT}`>,\n    callback: (payload: RealtimePostgresInsertPayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.UPDATE}`>,\n    callback: (payload: RealtimePostgresUpdatePayload<T>) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.POSTGRES_CHANGES}`,\n    filter: RealtimePostgresChangesFilter<`${REALTIME_POSTGRES_CHANGES_LISTEN_EVENT.DELETE}`>,\n    callback: (payload: RealtimePostgresDeletePayload<T>) => void\n  ): RealtimeChannel\n  /**\n   * The following is placed here to display on supabase.com/docs/reference/javascript/subscribe.\n   * @param type One of \"broadcast\", \"presence\", or \"postgres_changes\".\n   * @param filter Custom object specific to the Realtime feature detailing which payloads to receive.\n   * @param callback Function to be invoked when event handler is triggered.\n   */\n  on(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      [key: string]: any\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.BROADCAST}`,\n    filter: { event: string },\n    callback: (payload: {\n      type: `${REALTIME_LISTEN_TYPES.BROADCAST}`\n      event: string\n      payload: T\n    }) => void\n  ): RealtimeChannel\n  on<T extends { [key: string]: any }>(\n    type: `${REALTIME_LISTEN_TYPES.SYSTEM}`,\n    filter: {},\n    callback: (payload: any) => void\n  ): RealtimeChannel\n  on(\n    type: `${REALTIME_LISTEN_TYPES}`,\n    filter: { event: string; [key: string]: string },\n    callback: (payload: any) => void\n  ): RealtimeChannel {\n    if (\n      this.state === CHANNEL_STATES.joined &&\n      type === REALTIME_LISTEN_TYPES.PRESENCE\n    ) {\n      this.socket.log(\n        'channel',\n        `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`\n      )\n      this.unsubscribe().then(() => this.subscribe())\n    }\n    return this._on(type, filter, callback)\n  }\n  /**\n   * Sends a message into the channel.\n   *\n   * @param args Arguments to send to channel\n   * @param args.type The type of event to send\n   * @param args.event The name of the event being sent\n   * @param args.payload Payload to be sent\n   * @param opts Options to be used during the send process\n   */\n  async send(\n    args: {\n      type: 'broadcast' | 'presence' | 'postgres_changes'\n      event: string\n      payload?: any\n      [key: string]: any\n    },\n    opts: { [key: string]: any } = {}\n  ): Promise<RealtimeChannelSendResponse> {\n    if (!this._canPush() && args.type === 'broadcast') {\n      const { event, payload: endpoint_payload } = args\n      const authorization = this.socket.accessTokenValue\n        ? `Bearer ${this.socket.accessTokenValue}`\n        : ''\n      const options = {\n        method: 'POST',\n        headers: {\n          Authorization: authorization,\n          apikey: this.socket.apiKey ? this.socket.apiKey : '',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          messages: [\n            {\n              topic: this.subTopic,\n              event,\n              payload: endpoint_payload,\n              private: this.private,\n            },\n          ],\n        }),\n      }\n\n      try {\n        const response = await this._fetchWithTimeout(\n          this.broadcastEndpointURL,\n          options,\n          opts.timeout ?? this.timeout\n        )\n\n        await response.body?.cancel()\n        return response.ok ? 'ok' : 'error'\n      } catch (error: any) {\n        if (error.name === 'AbortError') {\n          return 'timed out'\n        } else {\n          return 'error'\n        }\n      }\n    } else {\n      return new Promise((resolve) => {\n        const push = this._push(args.type, args, opts.timeout || this.timeout)\n\n        if (args.type === 'broadcast' && !this.params?.config?.broadcast?.ack) {\n          resolve('ok')\n        }\n\n        push.receive('ok', () => resolve('ok'))\n        push.receive('error', () => resolve('error'))\n        push.receive('timeout', () => resolve('timed out'))\n      })\n    }\n  }\n\n  updateJoinPayload(payload: { [key: string]: any }): void {\n    this.joinPush.updatePayload(payload)\n  }\n\n  /**\n   * Leaves the channel.\n   *\n   * Unsubscribes from server events, and instructs channel to terminate on server.\n   * Triggers onClose() hooks.\n   *\n   * To receive leave acknowledgements, use the a `receive` hook to bind to the server ack, ie:\n   * channel.unsubscribe().receive(\"ok\", () => alert(\"left!\") )\n   */\n  unsubscribe(timeout = this.timeout): Promise<'ok' | 'timed out' | 'error'> {\n    this.state = CHANNEL_STATES.leaving\n    const onClose = () => {\n      this.socket.log('channel', `leave ${this.topic}`)\n      this._trigger(CHANNEL_EVENTS.close, 'leave', this._joinRef())\n    }\n\n    this.joinPush.destroy()\n\n    let leavePush: Push | null = null\n\n    return new Promise<RealtimeChannelSendResponse>((resolve) => {\n      leavePush = new Push(this, CHANNEL_EVENTS.leave, {}, timeout)\n      leavePush\n        .receive('ok', () => {\n          onClose()\n          resolve('ok')\n        })\n        .receive('timeout', () => {\n          onClose()\n          resolve('timed out')\n        })\n        .receive('error', () => {\n          resolve('error')\n        })\n\n      leavePush.send()\n      if (!this._canPush()) {\n        leavePush.trigger('ok', {})\n      }\n    }).finally(() => {\n      leavePush?.destroy()\n    })\n  }\n  /**\n   * Teardown the channel.\n   *\n   * Destroys and stops related timers.\n   */\n  teardown() {\n    this.pushBuffer.forEach((push: Push) => push.destroy())\n    this.pushBuffer = []\n    this.rejoinTimer.reset()\n    this.joinPush.destroy()\n    this.state = CHANNEL_STATES.closed\n    this.bindings = {}\n  }\n\n  /** @internal */\n\n  async _fetchWithTimeout(\n    url: string,\n    options: { [key: string]: any },\n    timeout: number\n  ) {\n    const controller = new AbortController()\n    const id = setTimeout(() => controller.abort(), timeout)\n\n    const response = await this.socket.fetch(url, {\n      ...options,\n      signal: controller.signal,\n    })\n\n    clearTimeout(id)\n\n    return response\n  }\n\n  /** @internal */\n  _push(\n    event: string,\n    payload: { [key: string]: any },\n    timeout = this.timeout\n  ) {\n    if (!this.joinedOnce) {\n      throw `tried to push '${event}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`\n    }\n    let pushEvent = new Push(this, event, payload, timeout)\n    if (this._canPush()) {\n      pushEvent.send()\n    } else {\n      this._addToPushBuffer(pushEvent)\n    }\n\n    return pushEvent\n  }\n\n  /** @internal */\n  _addToPushBuffer(pushEvent: Push) {\n    pushEvent.startTimeout()\n    this.pushBuffer.push(pushEvent)\n\n    // Enforce buffer size limit\n    if (this.pushBuffer.length > MAX_PUSH_BUFFER_SIZE) {\n      const removedPush = this.pushBuffer.shift()\n      if (removedPush) {\n        removedPush.destroy()\n        this.socket.log(\n          'channel',\n          `discarded push due to buffer overflow: ${removedPush.event}`,\n          removedPush.payload\n        )\n      }\n    }\n  }\n\n  /**\n   * Overridable message hook\n   *\n   * Receives all events for specialized message handling before dispatching to the channel callbacks.\n   * Must return the payload, modified or unmodified.\n   *\n   * @internal\n   */\n  _onMessage(_event: string, payload: any, _ref?: string) {\n    return payload\n  }\n\n  /** @internal */\n  _isMember(topic: string): boolean {\n    return this.topic === topic\n  }\n\n  /** @internal */\n  _joinRef(): string {\n    return this.joinPush.ref\n  }\n\n  /** @internal */\n  _trigger(type: string, payload?: any, ref?: string) {\n    const typeLower = type.toLocaleLowerCase()\n    const { close, error, leave, join } = CHANNEL_EVENTS\n    const events: string[] = [close, error, leave, join]\n    if (ref && events.indexOf(typeLower) >= 0 && ref !== this._joinRef()) {\n      return\n    }\n    let handledPayload = this._onMessage(typeLower, payload, ref)\n    if (payload && !handledPayload) {\n      throw 'channel onMessage callbacks must return the payload, modified or unmodified'\n    }\n\n    if (['insert', 'update', 'delete'].includes(typeLower)) {\n      this.bindings.postgres_changes\n        ?.filter((bind) => {\n          return (\n            bind.filter?.event === '*' ||\n            bind.filter?.event?.toLocaleLowerCase() === typeLower\n          )\n        })\n        .map((bind) => bind.callback(handledPayload, ref))\n    } else {\n      this.bindings[typeLower]\n        ?.filter((bind) => {\n          if (\n            ['broadcast', 'presence', 'postgres_changes'].includes(typeLower)\n          ) {\n            if ('id' in bind) {\n              const bindId = bind.id\n              const bindEvent = bind.filter?.event\n              return (\n                bindId &&\n                payload.ids?.includes(bindId) &&\n                (bindEvent === '*' ||\n                  bindEvent?.toLocaleLowerCase() ===\n                    payload.data?.type.toLocaleLowerCase())\n              )\n            } else {\n              const bindEvent = bind?.filter?.event?.toLocaleLowerCase()\n              return (\n                bindEvent === '*' ||\n                bindEvent === payload?.event?.toLocaleLowerCase()\n              )\n            }\n          } else {\n            return bind.type.toLocaleLowerCase() === typeLower\n          }\n        })\n        .map((bind) => {\n          if (typeof handledPayload === 'object' && 'ids' in handledPayload) {\n            const postgresChanges = handledPayload.data\n            const { schema, table, commit_timestamp, type, errors } =\n              postgresChanges\n            const enrichedPayload = {\n              schema: schema,\n              table: table,\n              commit_timestamp: commit_timestamp,\n              eventType: type,\n              new: {},\n              old: {},\n              errors: errors,\n            }\n            handledPayload = {\n              ...enrichedPayload,\n              ...this._getPayloadRecords(postgresChanges),\n            }\n          }\n          bind.callback(handledPayload, ref)\n        })\n    }\n  }\n\n  /** @internal */\n  _isClosed(): boolean {\n    return this.state === CHANNEL_STATES.closed\n  }\n\n  /** @internal */\n  _isJoined(): boolean {\n    return this.state === CHANNEL_STATES.joined\n  }\n\n  /** @internal */\n  _isJoining(): boolean {\n    return this.state === CHANNEL_STATES.joining\n  }\n\n  /** @internal */\n  _isLeaving(): boolean {\n    return this.state === CHANNEL_STATES.leaving\n  }\n\n  /** @internal */\n  _replyEventName(ref: string): string {\n    return `chan_reply_${ref}`\n  }\n\n  /** @internal */\n  _on(type: string, filter: { [key: string]: any }, callback: Function) {\n    const typeLower = type.toLocaleLowerCase()\n    const binding = {\n      type: typeLower,\n      filter: filter,\n      callback: callback,\n    }\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower].push(binding)\n    } else {\n      this.bindings[typeLower] = [binding]\n    }\n\n    return this\n  }\n\n  /** @internal */\n  _off(type: string, filter: { [key: string]: any }) {\n    const typeLower = type.toLocaleLowerCase()\n\n    if (this.bindings[typeLower]) {\n      this.bindings[typeLower] = this.bindings[typeLower].filter((bind) => {\n        return !(\n          bind.type?.toLocaleLowerCase() === typeLower &&\n          RealtimeChannel.isEqual(bind.filter, filter)\n        )\n      })\n    }\n    return this\n  }\n\n  /** @internal */\n  private static isEqual(\n    obj1: { [key: string]: string },\n    obj2: { [key: string]: string }\n  ) {\n    if (Object.keys(obj1).length !== Object.keys(obj2).length) {\n      return false\n    }\n\n    for (const k in obj1) {\n      if (obj1[k] !== obj2[k]) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /** @internal */\n  private _rejoinUntilConnected() {\n    this.rejoinTimer.scheduleTimeout()\n    if (this.socket.isConnected()) {\n      this._rejoin()\n    }\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel closes.\n   *\n   * @internal\n   */\n  private _onClose(callback: Function) {\n    this._on(CHANNEL_EVENTS.close, {}, callback)\n  }\n\n  /**\n   * Registers a callback that will be executed when the channel encounteres an error.\n   *\n   * @internal\n   */\n  private _onError(callback: Function) {\n    this._on(CHANNEL_EVENTS.error, {}, (reason: string) => callback(reason))\n  }\n\n  /**\n   * Returns `true` if the socket is connected and the channel has been joined.\n   *\n   * @internal\n   */\n  private _canPush(): boolean {\n    return this.socket.isConnected() && this._isJoined()\n  }\n\n  /** @internal */\n  private _rejoin(timeout = this.timeout): void {\n    if (this._isLeaving()) {\n      return\n    }\n    this.socket._leaveOpenTopic(this.topic)\n    this.state = CHANNEL_STATES.joining\n    this.joinPush.resend(timeout)\n  }\n\n  /** @internal */\n  private _getPayloadRecords(payload: any) {\n    const records = {\n      new: {},\n      old: {},\n    }\n\n    if (payload.type === 'INSERT' || payload.type === 'UPDATE') {\n      records.new = Transformers.convertChangeData(\n        payload.columns,\n        payload.record\n      )\n    }\n\n    if (payload.type === 'UPDATE' || payload.type === 'DELETE') {\n      records.old = Transformers.convertChangeData(\n        payload.columns,\n        payload.old_record\n      )\n    }\n\n    return records\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}