{"ast":null,"code":"import WebSocketFactory from'./lib/websocket-factory';import{CHANNEL_EVENTS,CONNECTION_STATE,DEFAULT_VERSION,DEFAULT_TIMEOUT,SOCKET_STATES,TRANSPORTS,VSN,WS_CLOSE_NORMAL}from'./lib/constants';import Serializer from'./lib/serializer';import Timer from'./lib/timer';import{httpEndpointURL}from'./lib/transformers';import RealtimeChannel from'./RealtimeChannel';const noop=()=>{};// Connection-related constants\nconst CONNECTION_TIMEOUTS={HEARTBEAT_INTERVAL:25000,RECONNECT_DELAY:10,HEARTBEAT_TIMEOUT_FALLBACK:100};const RECONNECT_INTERVALS=[1000,2000,5000,10000];const DEFAULT_RECONNECT_FALLBACK=10000;const WORKER_SCRIPT=\"\\n  addEventListener(\\\"message\\\", (e) => {\\n    if (e.data.event === \\\"start\\\") {\\n      setInterval(() => postMessage({ event: \\\"keepAlive\\\" }), e.data.interval);\\n    }\\n  });\";export default class RealtimeClient{/**\n     * Initializes the Socket.\n     *\n     * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n     * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n     * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n     * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n     * @param options.params The optional params to pass when connecting.\n     * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n     * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n     * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n     * @param options.logLevel Sets the log level for Realtime\n     * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n     * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n     * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n     * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n     * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n     */constructor(endPoint,options){var _a;this.accessTokenValue=null;this.apiKey=null;this.channels=new Array();this.endPoint='';this.httpEndpoint='';/** @deprecated headers cannot be set on websocket connections */this.headers={};this.params={};this.timeout=DEFAULT_TIMEOUT;this.transport=null;this.heartbeatIntervalMs=CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;this.heartbeatTimer=undefined;this.pendingHeartbeatRef=null;this.heartbeatCallback=noop;this.ref=0;this.reconnectTimer=null;this.logger=noop;this.conn=null;this.sendBuffer=[];this.serializer=new Serializer();this.stateChangeCallbacks={open:[],close:[],error:[],message:[]};this.accessToken=null;this._connectionState='disconnected';this._wasManualDisconnect=false;this._authPromise=null;/**\n         * Use either custom fetch, if provided, or default fetch to make HTTP requests\n         *\n         * @internal\n         */this._resolveFetch=customFetch=>{let _fetch;if(customFetch){_fetch=customFetch;}else if(typeof fetch==='undefined'){// Node.js environment without native fetch\n_fetch=function(){for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}return import('@supabase/node-fetch').then(_ref=>{let{default:fetch}=_ref;return fetch(...args);}).catch(error=>{throw new Error(\"Failed to load @supabase/node-fetch: \".concat(error.message,\". \")+\"This is required for HTTP requests in Node.js environments without native fetch.\");});};}else{_fetch=fetch;}return function(){return _fetch(...arguments);};};// Validate required parameters\nif(!((_a=options===null||options===void 0?void 0:options.params)===null||_a===void 0?void 0:_a.apikey)){throw new Error('API key is required to connect to Realtime');}this.apiKey=options.params.apikey;// Initialize endpoint URLs\nthis.endPoint=\"\".concat(endPoint,\"/\").concat(TRANSPORTS.websocket);this.httpEndpoint=httpEndpointURL(endPoint);this._initializeOptions(options);this._setupReconnectionTimer();this.fetch=this._resolveFetch(options===null||options===void 0?void 0:options.fetch);}/**\n     * Connects the socket, unless already connected.\n     */connect(){// Skip if already connecting, disconnecting, or connected\nif(this.isConnecting()||this.isDisconnecting()||this.conn!==null&&this.isConnected()){return;}this._setConnectionState('connecting');this._setAuthSafely('connect');// Establish WebSocket connection\nif(!this.transport){try{this.conn=WebSocketFactory.createWebSocket(this.endpointURL());}catch(error){this._setConnectionState('disconnected');throw new Error(\"WebSocket not available: \".concat(error.message));}}else{// Use custom transport if provided\nthis.conn=new this.transport(this.endpointURL());}this._setupConnectionHandlers();}/**\n     * Returns the URL of the websocket.\n     * @returns string The URL of the websocket.\n     */endpointURL(){return this._appendParams(this.endPoint,Object.assign({},this.params,{vsn:VSN}));}/**\n     * Disconnects the socket.\n     *\n     * @param code A numeric status code to send on disconnect.\n     * @param reason A custom reason for the disconnect.\n     */disconnect(code,reason){if(this.isDisconnecting()){return;}this._setConnectionState('disconnecting',true);if(this.conn){// Setup fallback timer to prevent hanging in disconnecting state\nconst fallbackTimer=setTimeout(()=>{this._setConnectionState('disconnected');},100);this.conn.onclose=()=>{clearTimeout(fallbackTimer);this._setConnectionState('disconnected');};// Close the WebSocket connection\nif(code){this.conn.close(code,reason!==null&&reason!==void 0?reason:'');}else{this.conn.close();}this._teardownConnection();}else{this._setConnectionState('disconnected');}}/**\n     * Returns all created channels\n     */getChannels(){return this.channels;}/**\n     * Unsubscribes and removes a single channel\n     * @param channel A RealtimeChannel instance\n     */async removeChannel(channel){const status=await channel.unsubscribe();if(this.channels.length===0){this.disconnect();}return status;}/**\n     * Unsubscribes and removes all channels\n     */async removeAllChannels(){const values_1=await Promise.all(this.channels.map(channel=>channel.unsubscribe()));this.channels=[];this.disconnect();return values_1;}/**\n     * Logs the message.\n     *\n     * For customized logging, `this.logger` can be overridden.\n     */log(kind,msg,data){this.logger(kind,msg,data);}/**\n     * Returns the current state of the socket.\n     */connectionState(){switch(this.conn&&this.conn.readyState){case SOCKET_STATES.connecting:return CONNECTION_STATE.Connecting;case SOCKET_STATES.open:return CONNECTION_STATE.Open;case SOCKET_STATES.closing:return CONNECTION_STATE.Closing;default:return CONNECTION_STATE.Closed;}}/**\n     * Returns `true` is the connection is open.\n     */isConnected(){return this.connectionState()===CONNECTION_STATE.Open;}/**\n     * Returns `true` if the connection is currently connecting.\n     */isConnecting(){return this._connectionState==='connecting';}/**\n     * Returns `true` if the connection is currently disconnecting.\n     */isDisconnecting(){return this._connectionState==='disconnecting';}channel(topic){let params=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{config:{}};const realtimeTopic=\"realtime:\".concat(topic);const exists=this.getChannels().find(c=>c.topic===realtimeTopic);if(!exists){const chan=new RealtimeChannel(\"realtime:\".concat(topic),params,this);this.channels.push(chan);return chan;}else{return exists;}}/**\n     * Push out a message if the socket is connected.\n     *\n     * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n     */push(data){const{topic,event,payload,ref}=data;const callback=()=>{this.encode(data,result=>{var _a;(_a=this.conn)===null||_a===void 0?void 0:_a.send(result);});};this.log('push',\"\".concat(topic,\" \").concat(event,\" (\").concat(ref,\")\"),payload);if(this.isConnected()){callback();}else{this.sendBuffer.push(callback);}}/**\n     * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n     *\n     * If param is null it will use the `accessToken` callback function or the token set on the client.\n     *\n     * On callback used, it will set the value of the token internal to the client.\n     *\n     * @param token A JWT string to override the token set on the client.\n     */async setAuth(){let token=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;this._authPromise=this._performAuth(token);try{await this._authPromise;}finally{this._authPromise=null;}}/**\n     * Sends a heartbeat message if the socket is connected.\n     */async sendHeartbeat(){var _a;if(!this.isConnected()){this.heartbeatCallback('disconnected');return;}// Handle heartbeat timeout and force reconnection if needed\nif(this.pendingHeartbeatRef){this.pendingHeartbeatRef=null;this.log('transport','heartbeat timeout. Attempting to re-establish connection');this.heartbeatCallback('timeout');// Force reconnection after heartbeat timeout\nthis._wasManualDisconnect=false;(_a=this.conn)===null||_a===void 0?void 0:_a.close(WS_CLOSE_NORMAL,'heartbeat timeout');setTimeout(()=>{var _a;if(!this.isConnected()){(_a=this.reconnectTimer)===null||_a===void 0?void 0:_a.scheduleTimeout();}},CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK);return;}// Send heartbeat message to server\nthis.pendingHeartbeatRef=this._makeRef();this.push({topic:'phoenix',event:'heartbeat',payload:{},ref:this.pendingHeartbeatRef});this.heartbeatCallback('sent');this._setAuthSafely('heartbeat');}onHeartbeat(callback){this.heartbeatCallback=callback;}/**\n     * Flushes send buffer\n     */flushSendBuffer(){if(this.isConnected()&&this.sendBuffer.length>0){this.sendBuffer.forEach(callback=>callback());this.sendBuffer=[];}}/**\n     * Return the next message ref, accounting for overflows\n     *\n     * @internal\n     */_makeRef(){let newRef=this.ref+1;if(newRef===this.ref){this.ref=0;}else{this.ref=newRef;}return this.ref.toString();}/**\n     * Unsubscribe from channels with the specified topic.\n     *\n     * @internal\n     */_leaveOpenTopic(topic){let dupChannel=this.channels.find(c=>c.topic===topic&&(c._isJoined()||c._isJoining()));if(dupChannel){this.log('transport',\"leaving duplicate topic \\\"\".concat(topic,\"\\\"\"));dupChannel.unsubscribe();}}/**\n     * Removes a subscription from the socket.\n     *\n     * @param channel An open subscription.\n     *\n     * @internal\n     */_remove(channel){this.channels=this.channels.filter(c=>c.topic!==channel.topic);}/** @internal */_onConnMessage(rawMessage){this.decode(rawMessage.data,msg=>{// Handle heartbeat responses\nif(msg.topic==='phoenix'&&msg.event==='phx_reply'){this.heartbeatCallback(msg.payload.status==='ok'?'ok':'error');}// Handle pending heartbeat reference cleanup\nif(msg.ref&&msg.ref===this.pendingHeartbeatRef){this.pendingHeartbeatRef=null;}// Log incoming message\nconst{topic,event,payload,ref}=msg;const refString=ref?\"(\".concat(ref,\")\"):'';const status=payload.status||'';this.log('receive',\"\".concat(status,\" \").concat(topic,\" \").concat(event,\" \").concat(refString).trim(),payload);// Route message to appropriate channels\nthis.channels.filter(channel=>channel._isMember(topic)).forEach(channel=>channel._trigger(event,payload,ref));this._triggerStateCallbacks('message',msg);});}/**\n     * Clear specific timer\n     * @internal\n     */_clearTimer(timer){var _a;if(timer==='heartbeat'&&this.heartbeatTimer){clearInterval(this.heartbeatTimer);this.heartbeatTimer=undefined;}else if(timer==='reconnect'){(_a=this.reconnectTimer)===null||_a===void 0?void 0:_a.reset();}}/**\n     * Clear all timers\n     * @internal\n     */_clearAllTimers(){this._clearTimer('heartbeat');this._clearTimer('reconnect');}/**\n     * Setup connection handlers for WebSocket events\n     * @internal\n     */_setupConnectionHandlers(){if(!this.conn)return;// Set binary type if supported (browsers and most WebSocket implementations)\nif('binaryType'in this.conn){;this.conn.binaryType='arraybuffer';}this.conn.onopen=()=>this._onConnOpen();this.conn.onerror=error=>this._onConnError(error);this.conn.onmessage=event=>this._onConnMessage(event);this.conn.onclose=event=>this._onConnClose(event);}/**\n     * Teardown connection and cleanup resources\n     * @internal\n     */_teardownConnection(){if(this.conn){this.conn.onopen=null;this.conn.onerror=null;this.conn.onmessage=null;this.conn.onclose=null;this.conn=null;}this._clearAllTimers();this.channels.forEach(channel=>channel.teardown());}/** @internal */_onConnOpen(){this._setConnectionState('connected');this.log('transport',\"connected to \".concat(this.endpointURL()));this.flushSendBuffer();this._clearTimer('reconnect');if(!this.worker){this._startHeartbeat();}else{if(!this.workerRef){this._startWorkerHeartbeat();}}this._triggerStateCallbacks('open');}/** @internal */_startHeartbeat(){this.heartbeatTimer&&clearInterval(this.heartbeatTimer);this.heartbeatTimer=setInterval(()=>this.sendHeartbeat(),this.heartbeatIntervalMs);}/** @internal */_startWorkerHeartbeat(){if(this.workerUrl){this.log('worker',\"starting worker for from \".concat(this.workerUrl));}else{this.log('worker',\"starting default worker\");}const objectUrl=this._workerObjectUrl(this.workerUrl);this.workerRef=new Worker(objectUrl);this.workerRef.onerror=error=>{this.log('worker','worker error',error.message);this.workerRef.terminate();};this.workerRef.onmessage=event=>{if(event.data.event==='keepAlive'){this.sendHeartbeat();}};this.workerRef.postMessage({event:'start',interval:this.heartbeatIntervalMs});}/** @internal */_onConnClose(event){var _a;this._setConnectionState('disconnected');this.log('transport','close',event);this._triggerChanError();this._clearTimer('heartbeat');// Only schedule reconnection if it wasn't a manual disconnect\nif(!this._wasManualDisconnect){(_a=this.reconnectTimer)===null||_a===void 0?void 0:_a.scheduleTimeout();}this._triggerStateCallbacks('close',event);}/** @internal */_onConnError(error){this._setConnectionState('disconnected');this.log('transport',\"\".concat(error));this._triggerChanError();this._triggerStateCallbacks('error',error);}/** @internal */_triggerChanError(){this.channels.forEach(channel=>channel._trigger(CHANNEL_EVENTS.error));}/** @internal */_appendParams(url,params){if(Object.keys(params).length===0){return url;}const prefix=url.match(/\\?/)?'&':'?';const query=new URLSearchParams(params);return\"\".concat(url).concat(prefix).concat(query);}_workerObjectUrl(url){let result_url;if(url){result_url=url;}else{const blob=new Blob([WORKER_SCRIPT],{type:'application/javascript'});result_url=URL.createObjectURL(blob);}return result_url;}/**\n     * Set connection state with proper state management\n     * @internal\n     */_setConnectionState(state){let manual=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;this._connectionState=state;if(state==='connecting'){this._wasManualDisconnect=false;}else if(state==='disconnecting'){this._wasManualDisconnect=manual;}}/**\n     * Perform the actual auth operation\n     * @internal\n     */async _performAuth(){let token=arguments.length>0&&arguments[0]!==undefined?arguments[0]:null;let tokenToSend;if(token){tokenToSend=token;}else if(this.accessToken){// Always call the accessToken callback to get fresh token\ntokenToSend=await this.accessToken();}else{tokenToSend=this.accessTokenValue;}if(this.accessTokenValue!=tokenToSend){this.accessTokenValue=tokenToSend;this.channels.forEach(channel=>{const payload={access_token:tokenToSend,version:DEFAULT_VERSION};tokenToSend&&channel.updateJoinPayload(payload);if(channel.joinedOnce&&channel._isJoined()){channel._push(CHANNEL_EVENTS.access_token,{access_token:tokenToSend});}});}}/**\n     * Wait for any in-flight auth operations to complete\n     * @internal\n     */async _waitForAuthIfNeeded(){if(this._authPromise){await this._authPromise;}}/**\n     * Safely call setAuth with standardized error handling\n     * @internal\n     */_setAuthSafely(){let context=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'general';this.setAuth().catch(e=>{this.log('error',\"error setting auth in \".concat(context),e);});}/**\n     * Trigger state change callbacks with proper error handling\n     * @internal\n     */_triggerStateCallbacks(event,data){try{this.stateChangeCallbacks[event].forEach(callback=>{try{callback(data);}catch(e){this.log('error',\"error in \".concat(event,\" callback\"),e);}});}catch(e){this.log('error',\"error triggering \".concat(event,\" callbacks\"),e);}}/**\n     * Setup reconnection timer with proper configuration\n     * @internal\n     */_setupReconnectionTimer(){this.reconnectTimer=new Timer(async()=>{setTimeout(async()=>{await this._waitForAuthIfNeeded();if(!this.isConnected()){this.connect();}},CONNECTION_TIMEOUTS.RECONNECT_DELAY);},this.reconnectAfterMs);}/**\n     * Initialize client options with defaults\n     * @internal\n     */_initializeOptions(options){var _a,_b,_c,_d,_e,_f,_g,_h;// Set defaults\nthis.transport=(_a=options===null||options===void 0?void 0:options.transport)!==null&&_a!==void 0?_a:null;this.timeout=(_b=options===null||options===void 0?void 0:options.timeout)!==null&&_b!==void 0?_b:DEFAULT_TIMEOUT;this.heartbeatIntervalMs=(_c=options===null||options===void 0?void 0:options.heartbeatIntervalMs)!==null&&_c!==void 0?_c:CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL;this.worker=(_d=options===null||options===void 0?void 0:options.worker)!==null&&_d!==void 0?_d:false;this.accessToken=(_e=options===null||options===void 0?void 0:options.accessToken)!==null&&_e!==void 0?_e:null;// Handle special cases\nif(options===null||options===void 0?void 0:options.params)this.params=options.params;if(options===null||options===void 0?void 0:options.logger)this.logger=options.logger;if((options===null||options===void 0?void 0:options.logLevel)||(options===null||options===void 0?void 0:options.log_level)){this.logLevel=options.logLevel||options.log_level;this.params=Object.assign(Object.assign({},this.params),{log_level:this.logLevel});}// Set up functions with defaults\nthis.reconnectAfterMs=(_f=options===null||options===void 0?void 0:options.reconnectAfterMs)!==null&&_f!==void 0?_f:tries=>{return RECONNECT_INTERVALS[tries-1]||DEFAULT_RECONNECT_FALLBACK;};this.encode=(_g=options===null||options===void 0?void 0:options.encode)!==null&&_g!==void 0?_g:(payload,callback)=>{return callback(JSON.stringify(payload));};this.decode=(_h=options===null||options===void 0?void 0:options.decode)!==null&&_h!==void 0?_h:this.serializer.decode.bind(this.serializer);// Handle worker setup\nif(this.worker){if(typeof window!=='undefined'&&!window.Worker){throw new Error('Web Worker is not supported');}this.workerUrl=options===null||options===void 0?void 0:options.workerUrl;}}}","map":{"version":3,"names":["WebSocketFactory","CHANNEL_EVENTS","CONNECTION_STATE","DEFAULT_VERSION","DEFAULT_TIMEOUT","SOCKET_STATES","TRANSPORTS","VSN","WS_CLOSE_NORMAL","Serializer","Timer","httpEndpointURL","RealtimeChannel","noop","CONNECTION_TIMEOUTS","HEARTBEAT_INTERVAL","RECONNECT_DELAY","HEARTBEAT_TIMEOUT_FALLBACK","RECONNECT_INTERVALS","DEFAULT_RECONNECT_FALLBACK","WORKER_SCRIPT","RealtimeClient","constructor","endPoint","options","accessTokenValue","apiKey","channels","Array","httpEndpoint","headers","params","timeout","transport","heartbeatIntervalMs","heartbeatTimer","undefined","pendingHeartbeatRef","heartbeatCallback","ref","reconnectTimer","logger","conn","sendBuffer","serializer","stateChangeCallbacks","open","close","error","message","accessToken","_connectionState","_wasManualDisconnect","_authPromise","_resolveFetch","customFetch","_fetch","fetch","_len","arguments","length","args","_key","then","_ref","default","catch","Error","concat","_a","apikey","websocket","_initializeOptions","_setupReconnectionTimer","connect","isConnecting","isDisconnecting","isConnected","_setConnectionState","_setAuthSafely","createWebSocket","endpointURL","_setupConnectionHandlers","_appendParams","Object","assign","vsn","disconnect","code","reason","fallbackTimer","setTimeout","onclose","clearTimeout","_teardownConnection","getChannels","removeChannel","channel","status","unsubscribe","removeAllChannels","values_1","Promise","all","map","log","kind","msg","data","connectionState","readyState","connecting","Connecting","Open","closing","Closing","Closed","topic","config","realtimeTopic","exists","find","c","chan","push","event","payload","callback","encode","result","send","setAuth","token","_performAuth","sendHeartbeat","scheduleTimeout","_makeRef","onHeartbeat","flushSendBuffer","forEach","newRef","toString","_leaveOpenTopic","dupChannel","_isJoined","_isJoining","_remove","filter","_onConnMessage","rawMessage","decode","refString","trim","_isMember","_trigger","_triggerStateCallbacks","_clearTimer","timer","clearInterval","reset","_clearAllTimers","binaryType","onopen","_onConnOpen","onerror","_onConnError","onmessage","_onConnClose","teardown","worker","_startHeartbeat","workerRef","_startWorkerHeartbeat","setInterval","workerUrl","objectUrl","_workerObjectUrl","Worker","terminate","postMessage","interval","_triggerChanError","url","keys","prefix","match","query","URLSearchParams","result_url","blob","Blob","type","URL","createObjectURL","state","manual","tokenToSend","access_token","version","updateJoinPayload","joinedOnce","_push","_waitForAuthIfNeeded","context","e","reconnectAfterMs","_b","_c","_d","_e","logLevel","log_level","_f","tries","_g","JSON","stringify","_h","bind","window"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/realtime-js/src/RealtimeClient.ts"],"sourcesContent":["import WebSocketFactory, { WebSocketLike } from './lib/websocket-factory'\n\nimport {\n  CHANNEL_EVENTS,\n  CONNECTION_STATE,\n  DEFAULT_VERSION,\n  DEFAULT_TIMEOUT,\n  SOCKET_STATES,\n  TRANSPORTS,\n  VSN,\n  WS_CLOSE_NORMAL,\n} from './lib/constants'\n\nimport Serializer from './lib/serializer'\nimport Timer from './lib/timer'\n\nimport { httpEndpointURL } from './lib/transformers'\nimport RealtimeChannel from './RealtimeChannel'\nimport type { RealtimeChannelOptions } from './RealtimeChannel'\n\ntype Fetch = typeof fetch\n\nexport type Channel = {\n  name: string\n  inserted_at: string\n  updated_at: string\n  id: number\n}\nexport type LogLevel = 'info' | 'warn' | 'error'\n\nexport type RealtimeMessage = {\n  topic: string\n  event: string\n  payload: any\n  ref: string\n  join_ref?: string\n}\n\nexport type RealtimeRemoveChannelResponse = 'ok' | 'timed out' | 'error'\nexport type HeartbeatStatus =\n  | 'sent'\n  | 'ok'\n  | 'error'\n  | 'timeout'\n  | 'disconnected'\n\nconst noop = () => {}\n\ntype RealtimeClientState =\n  | 'connecting'\n  | 'connected'\n  | 'disconnecting'\n  | 'disconnected'\n\n// Connection-related constants\nconst CONNECTION_TIMEOUTS = {\n  HEARTBEAT_INTERVAL: 25000,\n  RECONNECT_DELAY: 10,\n  HEARTBEAT_TIMEOUT_FALLBACK: 100,\n} as const\n\nconst RECONNECT_INTERVALS = [1000, 2000, 5000, 10000] as const\nconst DEFAULT_RECONNECT_FALLBACK = 10000\n\nexport interface WebSocketLikeConstructor {\n  new (\n    address: string | URL,\n    subprotocols?: string | string[] | undefined\n  ): WebSocketLike\n}\n\nexport interface WebSocketLikeError {\n  error: any\n  message: string\n  type: string\n}\n\nexport type RealtimeClientOptions = {\n  transport?: WebSocketLikeConstructor\n  timeout?: number\n  heartbeatIntervalMs?: number\n  logger?: Function\n  encode?: Function\n  decode?: Function\n  reconnectAfterMs?: Function\n  headers?: { [key: string]: string }\n  params?: { [key: string]: any }\n  //Deprecated: Use it in favour of correct casing `logLevel`\n  log_level?: LogLevel\n  logLevel?: LogLevel\n  fetch?: Fetch\n  worker?: boolean\n  workerUrl?: string\n  accessToken?: () => Promise<string | null>\n}\n\nconst WORKER_SCRIPT = `\n  addEventListener(\"message\", (e) => {\n    if (e.data.event === \"start\") {\n      setInterval(() => postMessage({ event: \"keepAlive\" }), e.data.interval);\n    }\n  });`\n\nexport default class RealtimeClient {\n  accessTokenValue: string | null = null\n  apiKey: string | null = null\n  channels: RealtimeChannel[] = new Array()\n  endPoint: string = ''\n  httpEndpoint: string = ''\n  /** @deprecated headers cannot be set on websocket connections */\n  headers?: { [key: string]: string } = {}\n  params?: { [key: string]: string } = {}\n  timeout: number = DEFAULT_TIMEOUT\n  transport: WebSocketLikeConstructor | null = null\n  heartbeatIntervalMs: number = CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL\n  heartbeatTimer: ReturnType<typeof setInterval> | undefined = undefined\n  pendingHeartbeatRef: string | null = null\n  heartbeatCallback: (status: HeartbeatStatus) => void = noop\n  ref: number = 0\n  reconnectTimer: Timer | null = null\n  logger: Function = noop\n  logLevel?: LogLevel\n  encode!: Function\n  decode!: Function\n  reconnectAfterMs!: Function\n  conn: WebSocketLike | null = null\n  sendBuffer: Function[] = []\n  serializer: Serializer = new Serializer()\n  stateChangeCallbacks: {\n    open: Function[]\n    close: Function[]\n    error: Function[]\n    message: Function[]\n  } = {\n    open: [],\n    close: [],\n    error: [],\n    message: [],\n  }\n  fetch: Fetch\n  accessToken: (() => Promise<string | null>) | null = null\n  worker?: boolean\n  workerUrl?: string\n  workerRef?: Worker\n  private _connectionState: RealtimeClientState = 'disconnected'\n  private _wasManualDisconnect: boolean = false\n  private _authPromise: Promise<void> | null = null\n\n  /**\n   * Initializes the Socket.\n   *\n   * @param endPoint The string WebSocket endpoint, ie, \"ws://example.com/socket\", \"wss://example.com\", \"/socket\" (inherited host & protocol)\n   * @param httpEndpoint The string HTTP endpoint, ie, \"https://example.com\", \"/\" (inherited host & protocol)\n   * @param options.transport The Websocket Transport, for example WebSocket. This can be a custom implementation\n   * @param options.timeout The default timeout in milliseconds to trigger push timeouts.\n   * @param options.params The optional params to pass when connecting.\n   * @param options.headers Deprecated: headers cannot be set on websocket connections and this option will be removed in the future.\n   * @param options.heartbeatIntervalMs The millisec interval to send a heartbeat message.\n   * @param options.logger The optional function for specialized logging, ie: logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }\n   * @param options.logLevel Sets the log level for Realtime\n   * @param options.encode The function to encode outgoing messages. Defaults to JSON: (payload, callback) => callback(JSON.stringify(payload))\n   * @param options.decode The function to decode incoming messages. Defaults to Serializer's decode.\n   * @param options.reconnectAfterMs he optional function that returns the millsec reconnect interval. Defaults to stepped backoff off.\n   * @param options.worker Use Web Worker to set a side flow. Defaults to false.\n   * @param options.workerUrl The URL of the worker script. Defaults to https://realtime.supabase.com/worker.js that includes a heartbeat event call to keep the connection alive.\n   */\n  constructor(endPoint: string, options?: RealtimeClientOptions) {\n    // Validate required parameters\n    if (!options?.params?.apikey) {\n      throw new Error('API key is required to connect to Realtime')\n    }\n    this.apiKey = options.params.apikey\n\n    // Initialize endpoint URLs\n    this.endPoint = `${endPoint}/${TRANSPORTS.websocket}`\n    this.httpEndpoint = httpEndpointURL(endPoint)\n\n    this._initializeOptions(options)\n    this._setupReconnectionTimer()\n    this.fetch = this._resolveFetch(options?.fetch)\n  }\n\n  /**\n   * Connects the socket, unless already connected.\n   */\n  connect(): void {\n    // Skip if already connecting, disconnecting, or connected\n    if (\n      this.isConnecting() ||\n      this.isDisconnecting() ||\n      (this.conn !== null && this.isConnected())\n    ) {\n      return\n    }\n\n    this._setConnectionState('connecting')\n    this._setAuthSafely('connect')\n\n    // Establish WebSocket connection\n    if (!this.transport) {\n      try {\n        this.conn = WebSocketFactory.createWebSocket(this.endpointURL())\n      } catch (error) {\n        this._setConnectionState('disconnected')\n        throw new Error(`WebSocket not available: ${(error as Error).message}`)\n      }\n    } else {\n      // Use custom transport if provided\n      this.conn = new this.transport!(this.endpointURL()) as WebSocketLike\n    }\n    this._setupConnectionHandlers()\n  }\n\n  /**\n   * Returns the URL of the websocket.\n   * @returns string The URL of the websocket.\n   */\n  endpointURL(): string {\n    return this._appendParams(\n      this.endPoint,\n      Object.assign({}, this.params, { vsn: VSN })\n    )\n  }\n\n  /**\n   * Disconnects the socket.\n   *\n   * @param code A numeric status code to send on disconnect.\n   * @param reason A custom reason for the disconnect.\n   */\n  disconnect(code?: number, reason?: string): void {\n    if (this.isDisconnecting()) {\n      return\n    }\n\n    this._setConnectionState('disconnecting', true)\n\n    if (this.conn) {\n      // Setup fallback timer to prevent hanging in disconnecting state\n      const fallbackTimer = setTimeout(() => {\n        this._setConnectionState('disconnected')\n      }, 100)\n\n      this.conn.onclose = () => {\n        clearTimeout(fallbackTimer)\n        this._setConnectionState('disconnected')\n      }\n\n      // Close the WebSocket connection\n      if (code) {\n        this.conn.close(code, reason ?? '')\n      } else {\n        this.conn.close()\n      }\n\n      this._teardownConnection()\n    } else {\n      this._setConnectionState('disconnected')\n    }\n  }\n\n  /**\n   * Returns all created channels\n   */\n  getChannels(): RealtimeChannel[] {\n    return this.channels\n  }\n\n  /**\n   * Unsubscribes and removes a single channel\n   * @param channel A RealtimeChannel instance\n   */\n  async removeChannel(\n    channel: RealtimeChannel\n  ): Promise<RealtimeRemoveChannelResponse> {\n    const status = await channel.unsubscribe()\n\n    if (this.channels.length === 0) {\n      this.disconnect()\n    }\n\n    return status\n  }\n\n  /**\n   * Unsubscribes and removes all channels\n   */\n  async removeAllChannels(): Promise<RealtimeRemoveChannelResponse[]> {\n    const values_1 = await Promise.all(\n      this.channels.map((channel) => channel.unsubscribe())\n    )\n    this.channels = []\n    this.disconnect()\n    return values_1\n  }\n\n  /**\n   * Logs the message.\n   *\n   * For customized logging, `this.logger` can be overridden.\n   */\n  log(kind: string, msg: string, data?: any) {\n    this.logger(kind, msg, data)\n  }\n\n  /**\n   * Returns the current state of the socket.\n   */\n  connectionState(): CONNECTION_STATE {\n    switch (this.conn && this.conn.readyState) {\n      case SOCKET_STATES.connecting:\n        return CONNECTION_STATE.Connecting\n      case SOCKET_STATES.open:\n        return CONNECTION_STATE.Open\n      case SOCKET_STATES.closing:\n        return CONNECTION_STATE.Closing\n      default:\n        return CONNECTION_STATE.Closed\n    }\n  }\n\n  /**\n   * Returns `true` is the connection is open.\n   */\n  isConnected(): boolean {\n    return this.connectionState() === CONNECTION_STATE.Open\n  }\n\n  /**\n   * Returns `true` if the connection is currently connecting.\n   */\n  isConnecting(): boolean {\n    return this._connectionState === 'connecting'\n  }\n\n  /**\n   * Returns `true` if the connection is currently disconnecting.\n   */\n  isDisconnecting(): boolean {\n    return this._connectionState === 'disconnecting'\n  }\n\n  channel(\n    topic: string,\n    params: RealtimeChannelOptions = { config: {} }\n  ): RealtimeChannel {\n    const realtimeTopic = `realtime:${topic}`\n    const exists = this.getChannels().find(\n      (c: RealtimeChannel) => c.topic === realtimeTopic\n    )\n\n    if (!exists) {\n      const chan = new RealtimeChannel(`realtime:${topic}`, params, this)\n      this.channels.push(chan)\n\n      return chan\n    } else {\n      return exists\n    }\n  }\n\n  /**\n   * Push out a message if the socket is connected.\n   *\n   * If the socket is not connected, the message gets enqueued within a local buffer, and sent out when a connection is next established.\n   */\n  push(data: RealtimeMessage): void {\n    const { topic, event, payload, ref } = data\n    const callback = () => {\n      this.encode(data, (result: any) => {\n        this.conn?.send(result)\n      })\n    }\n    this.log('push', `${topic} ${event} (${ref})`, payload)\n    if (this.isConnected()) {\n      callback()\n    } else {\n      this.sendBuffer.push(callback)\n    }\n  }\n\n  /**\n   * Sets the JWT access token used for channel subscription authorization and Realtime RLS.\n   *\n   * If param is null it will use the `accessToken` callback function or the token set on the client.\n   *\n   * On callback used, it will set the value of the token internal to the client.\n   *\n   * @param token A JWT string to override the token set on the client.\n   */\n  async setAuth(token: string | null = null): Promise<void> {\n    this._authPromise = this._performAuth(token)\n    try {\n      await this._authPromise\n    } finally {\n      this._authPromise = null\n    }\n  }\n  /**\n   * Sends a heartbeat message if the socket is connected.\n   */\n  async sendHeartbeat() {\n    if (!this.isConnected()) {\n      this.heartbeatCallback('disconnected')\n      return\n    }\n\n    // Handle heartbeat timeout and force reconnection if needed\n    if (this.pendingHeartbeatRef) {\n      this.pendingHeartbeatRef = null\n      this.log(\n        'transport',\n        'heartbeat timeout. Attempting to re-establish connection'\n      )\n      this.heartbeatCallback('timeout')\n\n      // Force reconnection after heartbeat timeout\n      this._wasManualDisconnect = false\n      this.conn?.close(WS_CLOSE_NORMAL, 'heartbeat timeout')\n\n      setTimeout(() => {\n        if (!this.isConnected()) {\n          this.reconnectTimer?.scheduleTimeout()\n        }\n      }, CONNECTION_TIMEOUTS.HEARTBEAT_TIMEOUT_FALLBACK)\n      return\n    }\n\n    // Send heartbeat message to server\n    this.pendingHeartbeatRef = this._makeRef()\n    this.push({\n      topic: 'phoenix',\n      event: 'heartbeat',\n      payload: {},\n      ref: this.pendingHeartbeatRef,\n    })\n    this.heartbeatCallback('sent')\n\n    this._setAuthSafely('heartbeat')\n  }\n\n  onHeartbeat(callback: (status: HeartbeatStatus) => void): void {\n    this.heartbeatCallback = callback\n  }\n  /**\n   * Flushes send buffer\n   */\n  flushSendBuffer() {\n    if (this.isConnected() && this.sendBuffer.length > 0) {\n      this.sendBuffer.forEach((callback) => callback())\n      this.sendBuffer = []\n    }\n  }\n\n  /**\n   * Use either custom fetch, if provided, or default fetch to make HTTP requests\n   *\n   * @internal\n   */\n  _resolveFetch = (customFetch?: Fetch): Fetch => {\n    let _fetch: Fetch\n    if (customFetch) {\n      _fetch = customFetch\n    } else if (typeof fetch === 'undefined') {\n      // Node.js environment without native fetch\n      _fetch = (...args) =>\n        import('@supabase/node-fetch' as any)\n          .then(({ default: fetch }) => fetch(...args))\n          .catch((error) => {\n            throw new Error(\n              `Failed to load @supabase/node-fetch: ${error.message}. ` +\n                `This is required for HTTP requests in Node.js environments without native fetch.`\n            )\n          })\n    } else {\n      _fetch = fetch\n    }\n    return (...args) => _fetch(...args)\n  }\n\n  /**\n   * Return the next message ref, accounting for overflows\n   *\n   * @internal\n   */\n  _makeRef(): string {\n    let newRef = this.ref + 1\n    if (newRef === this.ref) {\n      this.ref = 0\n    } else {\n      this.ref = newRef\n    }\n\n    return this.ref.toString()\n  }\n\n  /**\n   * Unsubscribe from channels with the specified topic.\n   *\n   * @internal\n   */\n  _leaveOpenTopic(topic: string): void {\n    let dupChannel = this.channels.find(\n      (c) => c.topic === topic && (c._isJoined() || c._isJoining())\n    )\n    if (dupChannel) {\n      this.log('transport', `leaving duplicate topic \"${topic}\"`)\n      dupChannel.unsubscribe()\n    }\n  }\n\n  /**\n   * Removes a subscription from the socket.\n   *\n   * @param channel An open subscription.\n   *\n   * @internal\n   */\n  _remove(channel: RealtimeChannel) {\n    this.channels = this.channels.filter((c) => c.topic !== channel.topic)\n  }\n\n  /** @internal */\n  private _onConnMessage(rawMessage: { data: any }) {\n    this.decode(rawMessage.data, (msg: RealtimeMessage) => {\n      // Handle heartbeat responses\n      if (msg.topic === 'phoenix' && msg.event === 'phx_reply') {\n        this.heartbeatCallback(msg.payload.status === 'ok' ? 'ok' : 'error')\n      }\n\n      // Handle pending heartbeat reference cleanup\n      if (msg.ref && msg.ref === this.pendingHeartbeatRef) {\n        this.pendingHeartbeatRef = null\n      }\n\n      // Log incoming message\n      const { topic, event, payload, ref } = msg\n      const refString = ref ? `(${ref})` : ''\n      const status = payload.status || ''\n      this.log(\n        'receive',\n        `${status} ${topic} ${event} ${refString}`.trim(),\n        payload\n      )\n\n      // Route message to appropriate channels\n      this.channels\n        .filter((channel: RealtimeChannel) => channel._isMember(topic))\n        .forEach((channel: RealtimeChannel) =>\n          channel._trigger(event, payload, ref)\n        )\n\n      this._triggerStateCallbacks('message', msg)\n    })\n  }\n\n  /**\n   * Clear specific timer\n   * @internal\n   */\n  private _clearTimer(timer: 'heartbeat' | 'reconnect'): void {\n    if (timer === 'heartbeat' && this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer)\n      this.heartbeatTimer = undefined\n    } else if (timer === 'reconnect') {\n      this.reconnectTimer?.reset()\n    }\n  }\n\n  /**\n   * Clear all timers\n   * @internal\n   */\n  private _clearAllTimers(): void {\n    this._clearTimer('heartbeat')\n    this._clearTimer('reconnect')\n  }\n\n  /**\n   * Setup connection handlers for WebSocket events\n   * @internal\n   */\n  private _setupConnectionHandlers(): void {\n    if (!this.conn) return\n\n    // Set binary type if supported (browsers and most WebSocket implementations)\n    if ('binaryType' in this.conn) {\n      ;(this.conn as any).binaryType = 'arraybuffer'\n    }\n\n    this.conn.onopen = () => this._onConnOpen()\n    this.conn.onerror = (error: Event) => this._onConnError(error)\n    this.conn.onmessage = (event: any) => this._onConnMessage(event)\n    this.conn.onclose = (event: any) => this._onConnClose(event)\n  }\n\n  /**\n   * Teardown connection and cleanup resources\n   * @internal\n   */\n  private _teardownConnection(): void {\n    if (this.conn) {\n      this.conn.onopen = null\n      this.conn.onerror = null\n      this.conn.onmessage = null\n      this.conn.onclose = null\n      this.conn = null\n    }\n    this._clearAllTimers()\n    this.channels.forEach((channel) => channel.teardown())\n  }\n\n  /** @internal */\n  private _onConnOpen() {\n    this._setConnectionState('connected')\n    this.log('transport', `connected to ${this.endpointURL()}`)\n    this.flushSendBuffer()\n    this._clearTimer('reconnect')\n\n    if (!this.worker) {\n      this._startHeartbeat()\n    } else {\n      if (!this.workerRef) {\n        this._startWorkerHeartbeat()\n      }\n    }\n\n    this._triggerStateCallbacks('open')\n  }\n  /** @internal */\n  private _startHeartbeat() {\n    this.heartbeatTimer && clearInterval(this.heartbeatTimer)\n    this.heartbeatTimer = setInterval(\n      () => this.sendHeartbeat(),\n      this.heartbeatIntervalMs\n    )\n  }\n\n  /** @internal */\n  private _startWorkerHeartbeat() {\n    if (this.workerUrl) {\n      this.log('worker', `starting worker for from ${this.workerUrl}`)\n    } else {\n      this.log('worker', `starting default worker`)\n    }\n    const objectUrl = this._workerObjectUrl(this.workerUrl!)\n    this.workerRef = new Worker(objectUrl)\n    this.workerRef.onerror = (error) => {\n      this.log('worker', 'worker error', (error as ErrorEvent).message)\n      this.workerRef!.terminate()\n    }\n    this.workerRef.onmessage = (event) => {\n      if (event.data.event === 'keepAlive') {\n        this.sendHeartbeat()\n      }\n    }\n    this.workerRef.postMessage({\n      event: 'start',\n      interval: this.heartbeatIntervalMs,\n    })\n  }\n  /** @internal */\n  private _onConnClose(event: any) {\n    this._setConnectionState('disconnected')\n    this.log('transport', 'close', event)\n    this._triggerChanError()\n    this._clearTimer('heartbeat')\n\n    // Only schedule reconnection if it wasn't a manual disconnect\n    if (!this._wasManualDisconnect) {\n      this.reconnectTimer?.scheduleTimeout()\n    }\n\n    this._triggerStateCallbacks('close', event)\n  }\n\n  /** @internal */\n  private _onConnError(error: Event) {\n    this._setConnectionState('disconnected')\n    this.log('transport', `${error}`)\n    this._triggerChanError()\n    this._triggerStateCallbacks('error', error)\n  }\n\n  /** @internal */\n  private _triggerChanError() {\n    this.channels.forEach((channel: RealtimeChannel) =>\n      channel._trigger(CHANNEL_EVENTS.error)\n    )\n  }\n\n  /** @internal */\n  private _appendParams(\n    url: string,\n    params: { [key: string]: string }\n  ): string {\n    if (Object.keys(params).length === 0) {\n      return url\n    }\n    const prefix = url.match(/\\?/) ? '&' : '?'\n    const query = new URLSearchParams(params)\n    return `${url}${prefix}${query}`\n  }\n\n  private _workerObjectUrl(url: string | undefined): string {\n    let result_url: string\n    if (url) {\n      result_url = url\n    } else {\n      const blob = new Blob([WORKER_SCRIPT], { type: 'application/javascript' })\n      result_url = URL.createObjectURL(blob)\n    }\n    return result_url\n  }\n\n  /**\n   * Set connection state with proper state management\n   * @internal\n   */\n  private _setConnectionState(\n    state: RealtimeClientState,\n    manual = false\n  ): void {\n    this._connectionState = state\n\n    if (state === 'connecting') {\n      this._wasManualDisconnect = false\n    } else if (state === 'disconnecting') {\n      this._wasManualDisconnect = manual\n    }\n  }\n\n  /**\n   * Perform the actual auth operation\n   * @internal\n   */\n  private async _performAuth(token: string | null = null): Promise<void> {\n    let tokenToSend: string | null\n\n    if (token) {\n      tokenToSend = token\n    } else if (this.accessToken) {\n      // Always call the accessToken callback to get fresh token\n      tokenToSend = await this.accessToken()\n    } else {\n      tokenToSend = this.accessTokenValue\n    }\n\n    if (this.accessTokenValue != tokenToSend) {\n      this.accessTokenValue = tokenToSend\n      this.channels.forEach((channel) => {\n        const payload = {\n          access_token: tokenToSend,\n          version: DEFAULT_VERSION,\n        }\n\n        tokenToSend && channel.updateJoinPayload(payload)\n\n        if (channel.joinedOnce && channel._isJoined()) {\n          channel._push(CHANNEL_EVENTS.access_token, {\n            access_token: tokenToSend,\n          })\n        }\n      })\n    }\n  }\n\n  /**\n   * Wait for any in-flight auth operations to complete\n   * @internal\n   */\n  private async _waitForAuthIfNeeded(): Promise<void> {\n    if (this._authPromise) {\n      await this._authPromise\n    }\n  }\n\n  /**\n   * Safely call setAuth with standardized error handling\n   * @internal\n   */\n  private _setAuthSafely(context = 'general'): void {\n    this.setAuth().catch((e) => {\n      this.log('error', `error setting auth in ${context}`, e)\n    })\n  }\n\n  /**\n   * Trigger state change callbacks with proper error handling\n   * @internal\n   */\n  private _triggerStateCallbacks(\n    event: keyof typeof this.stateChangeCallbacks,\n    data?: any\n  ): void {\n    try {\n      this.stateChangeCallbacks[event].forEach((callback) => {\n        try {\n          callback(data)\n        } catch (e) {\n          this.log('error', `error in ${event} callback`, e)\n        }\n      })\n    } catch (e) {\n      this.log('error', `error triggering ${event} callbacks`, e)\n    }\n  }\n\n  /**\n   * Setup reconnection timer with proper configuration\n   * @internal\n   */\n  private _setupReconnectionTimer(): void {\n    this.reconnectTimer = new Timer(async () => {\n      setTimeout(async () => {\n        await this._waitForAuthIfNeeded()\n        if (!this.isConnected()) {\n          this.connect()\n        }\n      }, CONNECTION_TIMEOUTS.RECONNECT_DELAY)\n    }, this.reconnectAfterMs)\n  }\n\n  /**\n   * Initialize client options with defaults\n   * @internal\n   */\n  private _initializeOptions(options?: RealtimeClientOptions): void {\n    // Set defaults\n    this.transport = options?.transport ?? null\n    this.timeout = options?.timeout ?? DEFAULT_TIMEOUT\n    this.heartbeatIntervalMs =\n      options?.heartbeatIntervalMs ?? CONNECTION_TIMEOUTS.HEARTBEAT_INTERVAL\n    this.worker = options?.worker ?? false\n    this.accessToken = options?.accessToken ?? null\n\n    // Handle special cases\n    if (options?.params) this.params = options.params\n    if (options?.logger) this.logger = options.logger\n    if (options?.logLevel || options?.log_level) {\n      this.logLevel = options.logLevel || options.log_level\n      this.params = { ...this.params, log_level: this.logLevel as string }\n    }\n\n    // Set up functions with defaults\n    this.reconnectAfterMs =\n      options?.reconnectAfterMs ??\n      ((tries: number) => {\n        return RECONNECT_INTERVALS[tries - 1] || DEFAULT_RECONNECT_FALLBACK\n      })\n\n    this.encode =\n      options?.encode ??\n      ((payload: JSON, callback: Function) => {\n        return callback(JSON.stringify(payload))\n      })\n\n    this.decode =\n      options?.decode ?? this.serializer.decode.bind(this.serializer)\n\n    // Handle worker setup\n    if (this.worker) {\n      if (typeof window !== 'undefined' && !window.Worker) {\n        throw new Error('Web Worker is not supported')\n      }\n      this.workerUrl = options?.workerUrl\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}