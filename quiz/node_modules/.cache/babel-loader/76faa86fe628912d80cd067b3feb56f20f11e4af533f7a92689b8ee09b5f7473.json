{"ast":null,"code":"\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});const PostgrestFilterBuilder_1=__importDefault(require(\"./PostgrestFilterBuilder\"));class PostgrestQueryBuilder{constructor(url,_ref){let{headers={},schema,fetch}=_ref;this.url=url;this.headers=headers;this.schema=schema;this.fetch=fetch;}/**\n     * Perform a SELECT query on the table or view.\n     *\n     * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n     *\n     * @param options - Named parameters\n     *\n     * @param options.head - When set to `true`, `data` will not be returned.\n     * Useful if you only need the count.\n     *\n     * @param options.count - Count algorithm to use to count rows in the table or view.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */select(columns){let{head=false,count}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const method=head?'HEAD':'GET';// Remove whitespaces except when quoted\nlet quoted=false;const cleanedColumns=(columns!==null&&columns!==void 0?columns:'*').split('').map(c=>{if(/\\s/.test(c)&&!quoted){return'';}if(c==='\"'){quoted=!quoted;}return c;}).join('');this.url.searchParams.set('select',cleanedColumns);if(count){this.headers['Prefer']=\"count=\".concat(count);}return new PostgrestFilterBuilder_1.default({method,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch,allowEmpty:false});}/**\n     * Perform an INSERT into the table or view.\n     *\n     * By default, inserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to insert. Pass an object to insert a single row\n     * or an array to insert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count inserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. Only applies for bulk\n     * inserts.\n     */insert(values){let{count,defaultToNull=true}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const method='POST';const prefersHeaders=[];if(this.headers['Prefer']){prefersHeaders.push(this.headers['Prefer']);}if(count){prefersHeaders.push(\"count=\".concat(count));}if(!defaultToNull){prefersHeaders.push('missing=default');}this.headers['Prefer']=prefersHeaders.join(',');if(Array.isArray(values)){const columns=values.reduce((acc,x)=>acc.concat(Object.keys(x)),[]);if(columns.length>0){const uniqueColumns=[...new Set(columns)].map(column=>\"\\\"\".concat(column,\"\\\"\"));this.url.searchParams.set('columns',uniqueColumns.join(','));}}return new PostgrestFilterBuilder_1.default({method,url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:this.fetch,allowEmpty:false});}/**\n     * Perform an UPSERT on the table or view. Depending on the column(s) passed\n     * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n     * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n     * exist, or if it does exist, perform an alternative action depending on\n     * `ignoreDuplicates`.\n     *\n     * By default, upserted rows are not returned. To return it, chain the call\n     * with `.select()`.\n     *\n     * @param values - The values to upsert with. Pass an object to upsert a\n     * single row or an array to upsert multiple rows.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n     * duplicate rows are determined. Two rows are duplicates if all the\n     * `onConflict` columns are equal.\n     *\n     * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n     * `false`, duplicate rows are merged with existing rows.\n     *\n     * @param options.count - Count algorithm to use to count upserted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     *\n     * @param options.defaultToNull - Make missing fields default to `null`.\n     * Otherwise, use the default value for the column. This only applies when\n     * inserting new rows, not when merging with existing rows under\n     * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n     */upsert(values){let{onConflict,ignoreDuplicates=false,count,defaultToNull=true}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const method='POST';const prefersHeaders=[\"resolution=\".concat(ignoreDuplicates?'ignore':'merge',\"-duplicates\")];if(onConflict!==undefined)this.url.searchParams.set('on_conflict',onConflict);if(this.headers['Prefer']){prefersHeaders.push(this.headers['Prefer']);}if(count){prefersHeaders.push(\"count=\".concat(count));}if(!defaultToNull){prefersHeaders.push('missing=default');}this.headers['Prefer']=prefersHeaders.join(',');if(Array.isArray(values)){const columns=values.reduce((acc,x)=>acc.concat(Object.keys(x)),[]);if(columns.length>0){const uniqueColumns=[...new Set(columns)].map(column=>\"\\\"\".concat(column,\"\\\"\"));this.url.searchParams.set('columns',uniqueColumns.join(','));}}return new PostgrestFilterBuilder_1.default({method,url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:this.fetch,allowEmpty:false});}/**\n     * Perform an UPDATE on the table or view.\n     *\n     * By default, updated rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param values - The values to update with\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count updated rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */update(values){let{count}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const method='PATCH';const prefersHeaders=[];if(this.headers['Prefer']){prefersHeaders.push(this.headers['Prefer']);}if(count){prefersHeaders.push(\"count=\".concat(count));}this.headers['Prefer']=prefersHeaders.join(',');return new PostgrestFilterBuilder_1.default({method,url:this.url,headers:this.headers,schema:this.schema,body:values,fetch:this.fetch,allowEmpty:false});}/**\n     * Perform a DELETE on the table or view.\n     *\n     * By default, deleted rows are not returned. To return it, chain the call\n     * with `.select()` after filters.\n     *\n     * @param options - Named parameters\n     *\n     * @param options.count - Count algorithm to use to count deleted rows.\n     *\n     * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n     * hood.\n     *\n     * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n     * statistics under the hood.\n     *\n     * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n     * numbers.\n     */delete(){let{count}=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};const method='DELETE';const prefersHeaders=[];if(count){prefersHeaders.push(\"count=\".concat(count));}if(this.headers['Prefer']){prefersHeaders.unshift(this.headers['Prefer']);}this.headers['Prefer']=prefersHeaders.join(',');return new PostgrestFilterBuilder_1.default({method,url:this.url,headers:this.headers,schema:this.schema,fetch:this.fetch,allowEmpty:false});}}exports.default=PostgrestQueryBuilder;","map":{"version":3,"names":["PostgrestFilterBuilder_1","__importDefault","require","PostgrestQueryBuilder","constructor","url","_ref","headers","schema","fetch","select","columns","head","count","arguments","length","undefined","method","quoted","cleanedColumns","split","map","c","test","join","searchParams","set","concat","default","allowEmpty","insert","values","defaultToNull","prefersHeaders","push","Array","isArray","reduce","acc","x","Object","keys","uniqueColumns","Set","column","body","upsert","onConflict","ignoreDuplicates","update","delete","unshift","exports"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/postgrest-js/src/PostgrestQueryBuilder.ts"],"sourcesContent":["import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport { Fetch, GenericSchema, GenericTable, GenericView } from './types'\n\nexport default class PostgrestQueryBuilder<\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  RelationName = unknown,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown\n> {\n  url: URL\n  headers: Record<string, string>\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n    }: {\n      headers?: Record<string, string>\n      schema?: string\n      fetch?: Fetch\n    }\n  ) {\n    this.url = url\n    this.headers = headers\n    this.schema = schema\n    this.fetch = fetch\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<Schema, Relation['Row'], RelationName, Relationships, Query>\n  >(\n    columns?: Query,\n    {\n      head = false,\n      count,\n    }: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], ResultOne[], RelationName, Relationships> {\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    if (count) {\n      this.headers['Prefer'] = `count=${count}`\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<ResultOne[]>)\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'POST'\n\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships>\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   */\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'POST'\n\n    const prefersHeaders = [`resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`]\n\n    if (onConflict !== undefined) this.url.searchParams.set('on_conflict', onConflict)\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (!defaultToNull) {\n      prefersHeaders.push('missing=default')\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        this.url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'PATCH'\n    const prefersHeaders = []\n    if (this.headers['Prefer']) {\n      prefersHeaders.push(this.headers['Prefer'])\n    }\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<Schema, Relation['Row'], null, RelationName, Relationships> {\n    const method = 'DELETE'\n    const prefersHeaders = []\n    if (count) {\n      prefersHeaders.push(`count=${count}`)\n    }\n    if (this.headers['Prefer']) {\n      prefersHeaders.unshift(this.headers['Prefer'])\n    }\n    this.headers['Prefer'] = prefersHeaders.join(',')\n\n    return new PostgrestFilterBuilder({\n      method,\n      url: this.url,\n      headers: this.headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      allowEmpty: false,\n    } as unknown as PostgrestBuilder<null>)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}