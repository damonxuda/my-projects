{"ast":null,"code":"var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};import{isStorageError,StorageError,StorageUnknownError}from'../lib/errors';import{get,head,post,put,remove}from'../lib/fetch';import{recursiveToCamel,resolveFetch}from'../lib/helpers';const DEFAULT_SEARCH_OPTIONS={limit:100,offset:0,sortBy:{column:'name',order:'asc'}};const DEFAULT_FILE_OPTIONS={cacheControl:'3600',contentType:'text/plain;charset=UTF-8',upsert:false};export default class StorageFileApi{constructor(url){let headers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let bucketId=arguments.length>2?arguments[2]:undefined;let fetch=arguments.length>3?arguments[3]:undefined;this.url=url;this.headers=headers;this.bucketId=bucketId;this.fetch=resolveFetch(fetch);}/**\n     * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n     *\n     * @param method HTTP method.\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */uploadOrUpdate(method,path,fileBody,fileOptions){return __awaiter(this,void 0,void 0,function*(){try{let body;const options=Object.assign(Object.assign({},DEFAULT_FILE_OPTIONS),fileOptions);let headers=Object.assign(Object.assign({},this.headers),method==='POST'&&{'x-upsert':String(options.upsert)});const metadata=options.metadata;if(typeof Blob!=='undefined'&&fileBody instanceof Blob){body=new FormData();body.append('cacheControl',options.cacheControl);if(metadata){body.append('metadata',this.encodeMetadata(metadata));}body.append('',fileBody);}else if(typeof FormData!=='undefined'&&fileBody instanceof FormData){body=fileBody;body.append('cacheControl',options.cacheControl);if(metadata){body.append('metadata',this.encodeMetadata(metadata));}}else{body=fileBody;headers['cache-control']=`max-age=${options.cacheControl}`;headers['content-type']=options.contentType;if(metadata){headers['x-metadata']=this.toBase64(this.encodeMetadata(metadata));}}if(fileOptions===null||fileOptions===void 0?void 0:fileOptions.headers){headers=Object.assign(Object.assign({},headers),fileOptions.headers);}const cleanPath=this._removeEmptyFolders(path);const _path=this._getFinalPath(cleanPath);const data=yield(method=='PUT'?put:post)(this.fetch,`${this.url}/object/${_path}`,body,Object.assign({headers},(options===null||options===void 0?void 0:options.duplex)?{duplex:options.duplex}:{}));return{data:{path:cleanPath,id:data.Id,fullPath:data.Key},error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Uploads a file to an existing bucket.\n     *\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */upload(path,fileBody,fileOptions){return __awaiter(this,void 0,void 0,function*(){return this.uploadOrUpdate('POST',path,fileBody,fileOptions);});}/**\n     * Upload a file with a token generated from `createSignedUploadUrl`.\n     * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n     * @param token The token generated from `createSignedUploadUrl`\n     * @param fileBody The body of the file to be stored in the bucket.\n     */uploadToSignedUrl(path,token,fileBody,fileOptions){return __awaiter(this,void 0,void 0,function*(){const cleanPath=this._removeEmptyFolders(path);const _path=this._getFinalPath(cleanPath);const url=new URL(this.url+`/object/upload/sign/${_path}`);url.searchParams.set('token',token);try{let body;const options=Object.assign({upsert:DEFAULT_FILE_OPTIONS.upsert},fileOptions);const headers=Object.assign(Object.assign({},this.headers),{'x-upsert':String(options.upsert)});if(typeof Blob!=='undefined'&&fileBody instanceof Blob){body=new FormData();body.append('cacheControl',options.cacheControl);body.append('',fileBody);}else if(typeof FormData!=='undefined'&&fileBody instanceof FormData){body=fileBody;body.append('cacheControl',options.cacheControl);}else{body=fileBody;headers['cache-control']=`max-age=${options.cacheControl}`;headers['content-type']=options.contentType;}const data=yield put(this.fetch,url.toString(),body,{headers});return{data:{path:cleanPath,fullPath:data.Key},error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Creates a signed upload URL.\n     * Signed upload URLs can be used to upload files to the bucket without further authentication.\n     * They are valid for 2 hours.\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n     */createSignedUploadUrl(path,options){return __awaiter(this,void 0,void 0,function*(){try{let _path=this._getFinalPath(path);const headers=Object.assign({},this.headers);if(options===null||options===void 0?void 0:options.upsert){headers['x-upsert']='true';}const data=yield post(this.fetch,`${this.url}/object/upload/sign/${_path}`,{},{headers});const url=new URL(this.url+data.url);const token=url.searchParams.get('token');if(!token){throw new StorageError('No token returned by API');}return{data:{signedUrl:url.toString(),path,token},error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Replaces an existing file at the specified path with a new one.\n     *\n     * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n     * @param fileBody The body of the file to be stored in the bucket.\n     */update(path,fileBody,fileOptions){return __awaiter(this,void 0,void 0,function*(){return this.uploadOrUpdate('PUT',path,fileBody,fileOptions);});}/**\n     * Moves an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n     * @param options The destination options.\n     */move(fromPath,toPath,options){return __awaiter(this,void 0,void 0,function*(){try{const data=yield post(this.fetch,`${this.url}/object/move`,{bucketId:this.bucketId,sourceKey:fromPath,destinationKey:toPath,destinationBucket:options===null||options===void 0?void 0:options.destinationBucket},{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Copies an existing file to a new path in the same bucket.\n     *\n     * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n     * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n     * @param options The destination options.\n     */copy(fromPath,toPath,options){return __awaiter(this,void 0,void 0,function*(){try{const data=yield post(this.fetch,`${this.url}/object/copy`,{bucketId:this.bucketId,sourceKey:fromPath,destinationKey:toPath,destinationBucket:options===null||options===void 0?void 0:options.destinationBucket},{headers:this.headers});return{data:{path:data.Key},error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param path The file path, including the current file name. For example `folder/image.png`.\n     * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */createSignedUrl(path,expiresIn,options){return __awaiter(this,void 0,void 0,function*(){try{let _path=this._getFinalPath(path);let data=yield post(this.fetch,`${this.url}/object/sign/${_path}`,Object.assign({expiresIn},(options===null||options===void 0?void 0:options.transform)?{transform:options.transform}:{}),{headers:this.headers});const downloadQueryParam=(options===null||options===void 0?void 0:options.download)?`&download=${options.download===true?'':options.download}`:'';const signedUrl=encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`);data={signedUrl};return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n     *\n     * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n     * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n     * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     */createSignedUrls(paths,expiresIn,options){return __awaiter(this,void 0,void 0,function*(){try{const data=yield post(this.fetch,`${this.url}/object/sign/${this.bucketId}`,{expiresIn,paths},{headers:this.headers});const downloadQueryParam=(options===null||options===void 0?void 0:options.download)?`&download=${options.download===true?'':options.download}`:'';return{data:data.map(datum=>Object.assign(Object.assign({},datum),{signedUrl:datum.signedURL?encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`):null})),error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n     *\n     * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n     * @param options.transform Transform the asset before serving it to the client.\n     */download(path,options){return __awaiter(this,void 0,void 0,function*(){const wantsTransformation=typeof(options===null||options===void 0?void 0:options.transform)!=='undefined';const renderPath=wantsTransformation?'render/image/authenticated':'object';const transformationQuery=this.transformOptsToQueryString((options===null||options===void 0?void 0:options.transform)||{});const queryString=transformationQuery?`?${transformationQuery}`:'';try{const _path=this._getFinalPath(path);const res=yield get(this.fetch,`${this.url}/${renderPath}/${_path}${queryString}`,{headers:this.headers,noResolveJson:true});const data=yield res.blob();return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Retrieves the details of an existing file.\n     * @param path\n     */info(path){return __awaiter(this,void 0,void 0,function*(){const _path=this._getFinalPath(path);try{const data=yield get(this.fetch,`${this.url}/object/info/${_path}`,{headers:this.headers});return{data:recursiveToCamel(data),error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Checks the existence of a file.\n     * @param path\n     */exists(path){return __awaiter(this,void 0,void 0,function*(){const _path=this._getFinalPath(path);try{yield head(this.fetch,`${this.url}/object/${_path}`,{headers:this.headers});return{data:true,error:null};}catch(error){if(isStorageError(error)&&error instanceof StorageUnknownError){const originalError=error.originalError;if([400,404].includes(originalError===null||originalError===void 0?void 0:originalError.status)){return{data:false,error};}}throw error;}});}/**\n     * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n     * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n     *\n     * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n     * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n     * @param options.transform Transform the asset before serving it to the client.\n     */getPublicUrl(path,options){const _path=this._getFinalPath(path);const _queryString=[];const downloadQueryParam=(options===null||options===void 0?void 0:options.download)?`download=${options.download===true?'':options.download}`:'';if(downloadQueryParam!==''){_queryString.push(downloadQueryParam);}const wantsTransformation=typeof(options===null||options===void 0?void 0:options.transform)!=='undefined';const renderPath=wantsTransformation?'render/image':'object';const transformationQuery=this.transformOptsToQueryString((options===null||options===void 0?void 0:options.transform)||{});if(transformationQuery!==''){_queryString.push(transformationQuery);}let queryString=_queryString.join('&');if(queryString!==''){queryString=`?${queryString}`;}return{data:{publicUrl:encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`)}};}/**\n     * Deletes files within the same bucket\n     *\n     * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n     */remove(paths){return __awaiter(this,void 0,void 0,function*(){try{const data=yield remove(this.fetch,`${this.url}/object/${this.bucketId}`,{prefixes:paths},{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Get file metadata\n     * @param id the file id to retrieve metadata\n     */// async getMetadata(\n//   id: string\n// ): Promise<\n//   | {\n//       data: Metadata\n//       error: null\n//     }\n//   | {\n//       data: null\n//       error: StorageError\n//     }\n// > {\n//   try {\n//     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n//     return { data, error: null }\n//   } catch (error) {\n//     if (isStorageError(error)) {\n//       return { data: null, error }\n//     }\n//     throw error\n//   }\n// }\n/**\n     * Update file metadata\n     * @param id the file id to update metadata\n     * @param meta the new file metadata\n     */// async updateMetadata(\n//   id: string,\n//   meta: Metadata\n// ): Promise<\n//   | {\n//       data: Metadata\n//       error: null\n//     }\n//   | {\n//       data: null\n//       error: StorageError\n//     }\n// > {\n//   try {\n//     const data = await post(\n//       this.fetch,\n//       `${this.url}/metadata/${id}`,\n//       { ...meta },\n//       { headers: this.headers }\n//     )\n//     return { data, error: null }\n//   } catch (error) {\n//     if (isStorageError(error)) {\n//       return { data: null, error }\n//     }\n//     throw error\n//   }\n// }\n/**\n     * Lists all the files within a bucket.\n     * @param path The folder path.\n     * @param options Search options including limit (defaults to 100), offset, sortBy, and search\n     */list(path,options,parameters){return __awaiter(this,void 0,void 0,function*(){try{const body=Object.assign(Object.assign(Object.assign({},DEFAULT_SEARCH_OPTIONS),options),{prefix:path||''});const data=yield post(this.fetch,`${this.url}/object/list/${this.bucketId}`,body,{headers:this.headers},parameters);return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}encodeMetadata(metadata){return JSON.stringify(metadata);}toBase64(data){if(typeof Buffer!=='undefined'){return Buffer.from(data).toString('base64');}return btoa(data);}_getFinalPath(path){return`${this.bucketId}/${path.replace(/^\\/+/,'')}`;}_removeEmptyFolders(path){return path.replace(/^\\/|\\/$/g,'').replace(/\\/+/g,'/');}transformOptsToQueryString(transform){const params=[];if(transform.width){params.push(`width=${transform.width}`);}if(transform.height){params.push(`height=${transform.height}`);}if(transform.resize){params.push(`resize=${transform.resize}`);}if(transform.format){params.push(`format=${transform.format}`);}if(transform.quality){params.push(`quality=${transform.quality}`);}return params.join('&');}}","map":{"version":3,"names":["isStorageError","StorageError","StorageUnknownError","get","head","post","put","remove","recursiveToCamel","resolveFetch","DEFAULT_SEARCH_OPTIONS","limit","offset","sortBy","column","order","DEFAULT_FILE_OPTIONS","cacheControl","contentType","upsert","StorageFileApi","constructor","url","headers","arguments","length","undefined","bucketId","fetch","uploadOrUpdate","method","path","fileBody","fileOptions","body","options","Object","assign","String","metadata","Blob","FormData","append","encodeMetadata","toBase64","cleanPath","_removeEmptyFolders","_path","_getFinalPath","data","duplex","id","Id","fullPath","Key","error","upload","uploadToSignedUrl","token","URL","searchParams","set","toString","createSignedUploadUrl","signedUrl","update","move","fromPath","toPath","sourceKey","destinationKey","destinationBucket","copy","createSignedUrl","expiresIn","transform","downloadQueryParam","download","encodeURI","signedURL","createSignedUrls","paths","map","datum","wantsTransformation","renderPath","transformationQuery","transformOptsToQueryString","queryString","res","noResolveJson","blob","info","exists","originalError","includes","status","getPublicUrl","_queryString","push","join","publicUrl","prefixes","list","parameters","prefix","JSON","stringify","Buffer","from","btoa","replace","params","width","height","resize","format","quality"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/storage-js/src/packages/StorageFileApi.ts"],"sourcesContent":["import { isStorageError, StorageError, StorageUnknownError } from '../lib/errors'\nimport { Fetch, get, head, post, put, remove } from '../lib/fetch'\nimport { recursiveToCamel, resolveFetch } from '../lib/helpers'\nimport {\n  FileObject,\n  FileOptions,\n  SearchOptions,\n  FetchParameters,\n  TransformOptions,\n  DestinationOptions,\n  FileObjectV2,\n  Camelize,\n} from '../lib/types'\n\nconst DEFAULT_SEARCH_OPTIONS = {\n  limit: 100,\n  offset: 0,\n  sortBy: {\n    column: 'name',\n    order: 'asc',\n  },\n}\n\nconst DEFAULT_FILE_OPTIONS: FileOptions = {\n  cacheControl: '3600',\n  contentType: 'text/plain;charset=UTF-8',\n  upsert: false,\n}\n\ntype FileBody =\n  | ArrayBuffer\n  | ArrayBufferView\n  | Blob\n  | Buffer\n  | File\n  | FormData\n  | NodeJS.ReadableStream\n  | ReadableStream<Uint8Array>\n  | URLSearchParams\n  | string\n\nexport default class StorageFileApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected bucketId?: string\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    bucketId?: string,\n    fetch?: Fetch\n  ) {\n    this.url = url\n    this.headers = headers\n    this.bucketId = bucketId\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Uploads a file to an existing bucket or replaces an existing file at the specified path with a new one.\n   *\n   * @param method HTTP method.\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  private async uploadOrUpdate(\n    method: 'POST' | 'PUT',\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let body\n      const options = { ...DEFAULT_FILE_OPTIONS, ...fileOptions }\n      let headers: Record<string, string> = {\n        ...this.headers,\n        ...(method === 'POST' && { 'x-upsert': String(options.upsert as boolean) }),\n      }\n\n      const metadata = options.metadata\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        if (metadata) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n        if (metadata) {\n          body.append('metadata', this.encodeMetadata(metadata))\n        }\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n\n        if (metadata) {\n          headers['x-metadata'] = this.toBase64(this.encodeMetadata(metadata))\n        }\n      }\n\n      if (fileOptions?.headers) {\n        headers = { ...headers, ...fileOptions.headers }\n      }\n\n      const cleanPath = this._removeEmptyFolders(path)\n      const _path = this._getFinalPath(cleanPath)\n      const data = await (method == 'PUT' ? put : post)(\n        this.fetch,\n        `${this.url}/object/${_path}`,\n        body as object,\n        { headers, ...(options?.duplex ? { duplex: options.duplex } : {}) }\n      )\n\n      return {\n        data: { path: cleanPath, id: data.Id, fullPath: data.Key },\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Uploads a file to an existing bucket.\n   *\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async upload(\n    path: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('POST', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Upload a file with a token generated from `createSignedUploadUrl`.\n   * @param path The file path, including the file name. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to upload.\n   * @param token The token generated from `createSignedUploadUrl`\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async uploadToSignedUrl(\n    path: string,\n    token: string,\n    fileBody: FileBody,\n    fileOptions?: FileOptions\n  ) {\n    const cleanPath = this._removeEmptyFolders(path)\n    const _path = this._getFinalPath(cleanPath)\n\n    const url = new URL(this.url + `/object/upload/sign/${_path}`)\n    url.searchParams.set('token', token)\n\n    try {\n      let body\n      const options = { upsert: DEFAULT_FILE_OPTIONS.upsert, ...fileOptions }\n      const headers: Record<string, string> = {\n        ...this.headers,\n        ...{ 'x-upsert': String(options.upsert as boolean) },\n      }\n\n      if (typeof Blob !== 'undefined' && fileBody instanceof Blob) {\n        body = new FormData()\n        body.append('cacheControl', options.cacheControl as string)\n        body.append('', fileBody)\n      } else if (typeof FormData !== 'undefined' && fileBody instanceof FormData) {\n        body = fileBody\n        body.append('cacheControl', options.cacheControl as string)\n      } else {\n        body = fileBody\n        headers['cache-control'] = `max-age=${options.cacheControl}`\n        headers['content-type'] = options.contentType as string\n      }\n\n      const data = await put(this.fetch, url.toString(), body as object, { headers })\n\n      return {\n        data: { path: cleanPath, fullPath: data.Key },\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed upload URL.\n   * Signed upload URLs can be used to upload files to the bucket without further authentication.\n   * They are valid for 2 hours.\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param options.upsert If set to true, allows the file to be overwritten if it already exists.\n   */\n  async createSignedUploadUrl(\n    path: string,\n    options?: { upsert: boolean }\n  ): Promise<\n    | {\n        data: { signedUrl: string; token: string; path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      const headers = { ...this.headers }\n\n      if (options?.upsert) {\n        headers['x-upsert'] = 'true'\n      }\n\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/upload/sign/${_path}`,\n        {},\n        { headers }\n      )\n\n      const url = new URL(this.url + data.url)\n\n      const token = url.searchParams.get('token')\n\n      if (!token) {\n        throw new StorageError('No token returned by API')\n      }\n\n      return { data: { signedUrl: url.toString(), path, token }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Replaces an existing file at the specified path with a new one.\n   *\n   * @param path The relative file path. Should be of the format `folder/subfolder/filename.png`. The bucket must already exist before attempting to update.\n   * @param fileBody The body of the file to be stored in the bucket.\n   */\n  async update(\n    path: string,\n    fileBody:\n      | ArrayBuffer\n      | ArrayBufferView\n      | Blob\n      | Buffer\n      | File\n      | FormData\n      | NodeJS.ReadableStream\n      | ReadableStream<Uint8Array>\n      | URLSearchParams\n      | string,\n    fileOptions?: FileOptions\n  ): Promise<\n    | {\n        data: { id: string; path: string; fullPath: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    return this.uploadOrUpdate('PUT', path, fileBody, fileOptions)\n  }\n\n  /**\n   * Moves an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-new.png`.\n   * @param options The destination options.\n   */\n  async move(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/move`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Copies an existing file to a new path in the same bucket.\n   *\n   * @param fromPath The original file path, including the current file name. For example `folder/image.png`.\n   * @param toPath The new file path, including the new file name. For example `folder/image-copy.png`.\n   * @param options The destination options.\n   */\n  async copy(\n    fromPath: string,\n    toPath: string,\n    options?: DestinationOptions\n  ): Promise<\n    | {\n        data: { path: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/copy`,\n        {\n          bucketId: this.bucketId,\n          sourceKey: fromPath,\n          destinationKey: toPath,\n          destinationBucket: options?.destinationBucket,\n        },\n        { headers: this.headers }\n      )\n      return { data: { path: data.Key }, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a signed URL. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param path The file path, including the current file name. For example `folder/image.png`.\n   * @param expiresIn The number of seconds until the signed URL expires. For example, `60` for a URL which is valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async createSignedUrl(\n    path: string,\n    expiresIn: number,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: { signedUrl: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      let _path = this._getFinalPath(path)\n\n      let data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${_path}`,\n        { expiresIn, ...(options?.transform ? { transform: options.transform } : {}) },\n        { headers: this.headers }\n      )\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      const signedUrl = encodeURI(`${this.url}${data.signedURL}${downloadQueryParam}`)\n      data = { signedUrl }\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates multiple signed URLs. Use a signed URL to share a file for a fixed amount of time.\n   *\n   * @param paths The file paths to be downloaded, including the current file names. For example `['folder/image.png', 'folder2/image2.png']`.\n   * @param expiresIn The number of seconds until the signed URLs expire. For example, `60` for URLs which are valid for one minute.\n   * @param options.download triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   */\n  async createSignedUrls(\n    paths: string[],\n    expiresIn: number,\n    options?: { download: string | boolean }\n  ): Promise<\n    | {\n        data: { error: string | null; path: string | null; signedUrl: string }[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/sign/${this.bucketId}`,\n        { expiresIn, paths },\n        { headers: this.headers }\n      )\n\n      const downloadQueryParam = options?.download\n        ? `&download=${options.download === true ? '' : options.download}`\n        : ''\n      return {\n        data: data.map((datum: { signedURL: string }) => ({\n          ...datum,\n          signedUrl: datum.signedURL\n            ? encodeURI(`${this.url}${datum.signedURL}${downloadQueryParam}`)\n            : null,\n        })),\n        error: null,\n      }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Downloads a file from a private bucket. For public buckets, make a request to the URL returned from `getPublicUrl` instead.\n   *\n   * @param path The full path and file name of the file to be downloaded. For example `folder/image.png`.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  async download(\n    path: string,\n    options?: { transform?: TransformOptions }\n  ): Promise<\n    | {\n        data: Blob\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image/authenticated' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n    const queryString = transformationQuery ? `?${transformationQuery}` : ''\n\n    try {\n      const _path = this._getFinalPath(path)\n      const res = await get(this.fetch, `${this.url}/${renderPath}/${_path}${queryString}`, {\n        headers: this.headers,\n        noResolveJson: true,\n      })\n      const data = await res.blob()\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing file.\n   * @param path\n   */\n  async info(\n    path: string\n  ): Promise<\n    | {\n        data: Camelize<FileObjectV2>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      const data = await get(this.fetch, `${this.url}/object/info/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: recursiveToCamel(data) as Camelize<FileObjectV2>, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks the existence of a file.\n   * @param path\n   */\n  async exists(\n    path: string\n  ): Promise<\n    | {\n        data: boolean\n        error: null\n      }\n    | {\n        data: boolean\n        error: StorageError\n      }\n  > {\n    const _path = this._getFinalPath(path)\n\n    try {\n      await head(this.fetch, `${this.url}/object/${_path}`, {\n        headers: this.headers,\n      })\n\n      return { data: true, error: null }\n    } catch (error) {\n      if (isStorageError(error) && error instanceof StorageUnknownError) {\n        const originalError = (error.originalError as unknown) as { status: number }\n\n        if ([400, 404].includes(originalError?.status)) {\n          return { data: false, error }\n        }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * A simple convenience function to get the URL for an asset in a public bucket. If you do not want to use this function, you can construct the public URL by concatenating the bucket URL with the path to the asset.\n   * This function does not verify if the bucket is public. If a public URL is created for a bucket which is not public, you will not be able to download the asset.\n   *\n   * @param path The path and name of the file to generate the public URL for. For example `folder/image.png`.\n   * @param options.download Triggers the file as a download if set to true. Set this parameter as the name of the file if you want to trigger the download with a different filename.\n   * @param options.transform Transform the asset before serving it to the client.\n   */\n  getPublicUrl(\n    path: string,\n    options?: { download?: string | boolean; transform?: TransformOptions }\n  ): { data: { publicUrl: string } } {\n    const _path = this._getFinalPath(path)\n    const _queryString = []\n\n    const downloadQueryParam = options?.download\n      ? `download=${options.download === true ? '' : options.download}`\n      : ''\n\n    if (downloadQueryParam !== '') {\n      _queryString.push(downloadQueryParam)\n    }\n\n    const wantsTransformation = typeof options?.transform !== 'undefined'\n    const renderPath = wantsTransformation ? 'render/image' : 'object'\n    const transformationQuery = this.transformOptsToQueryString(options?.transform || {})\n\n    if (transformationQuery !== '') {\n      _queryString.push(transformationQuery)\n    }\n\n    let queryString = _queryString.join('&')\n    if (queryString !== '') {\n      queryString = `?${queryString}`\n    }\n\n    return {\n      data: { publicUrl: encodeURI(`${this.url}/${renderPath}/public/${_path}${queryString}`) },\n    }\n  }\n\n  /**\n   * Deletes files within the same bucket\n   *\n   * @param paths An array of files to delete, including the path and file name. For example [`'folder/image.png'`].\n   */\n  async remove(\n    paths: string[]\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/object/${this.bucketId}`,\n        { prefixes: paths },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Get file metadata\n   * @param id the file id to retrieve metadata\n   */\n  // async getMetadata(\n  //   id: string\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await get(this.fetch, `${this.url}/metadata/${id}`, { headers: this.headers })\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Update file metadata\n   * @param id the file id to update metadata\n   * @param meta the new file metadata\n   */\n  // async updateMetadata(\n  //   id: string,\n  //   meta: Metadata\n  // ): Promise<\n  //   | {\n  //       data: Metadata\n  //       error: null\n  //     }\n  //   | {\n  //       data: null\n  //       error: StorageError\n  //     }\n  // > {\n  //   try {\n  //     const data = await post(\n  //       this.fetch,\n  //       `${this.url}/metadata/${id}`,\n  //       { ...meta },\n  //       { headers: this.headers }\n  //     )\n  //     return { data, error: null }\n  //   } catch (error) {\n  //     if (isStorageError(error)) {\n  //       return { data: null, error }\n  //     }\n\n  //     throw error\n  //   }\n  // }\n\n  /**\n   * Lists all the files within a bucket.\n   * @param path The folder path.\n   * @param options Search options including limit (defaults to 100), offset, sortBy, and search\n   */\n  async list(\n    path?: string,\n    options?: SearchOptions,\n    parameters?: FetchParameters\n  ): Promise<\n    | {\n        data: FileObject[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const body = { ...DEFAULT_SEARCH_OPTIONS, ...options, prefix: path || '' }\n      const data = await post(\n        this.fetch,\n        `${this.url}/object/list/${this.bucketId}`,\n        body,\n        { headers: this.headers },\n        parameters\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  protected encodeMetadata(metadata: Record<string, any>) {\n    return JSON.stringify(metadata)\n  }\n\n  toBase64(data: string) {\n    if (typeof Buffer !== 'undefined') {\n      return Buffer.from(data).toString('base64')\n    }\n    return btoa(data)\n  }\n\n  private _getFinalPath(path: string) {\n    return `${this.bucketId}/${path.replace(/^\\/+/, '')}`\n  }\n\n  private _removeEmptyFolders(path: string) {\n    return path.replace(/^\\/|\\/$/g, '').replace(/\\/+/g, '/')\n  }\n\n  private transformOptsToQueryString(transform: TransformOptions) {\n    const params = []\n    if (transform.width) {\n      params.push(`width=${transform.width}`)\n    }\n\n    if (transform.height) {\n      params.push(`height=${transform.height}`)\n    }\n\n    if (transform.resize) {\n      params.push(`resize=${transform.resize}`)\n    }\n\n    if (transform.format) {\n      params.push(`format=${transform.format}`)\n    }\n\n    if (transform.quality) {\n      params.push(`quality=${transform.quality}`)\n    }\n\n    return params.join('&')\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}