{"ast":null,"code":"\"use strict\";var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});const PostgrestTransformBuilder_1=__importDefault(require(\"./PostgrestTransformBuilder\"));class PostgrestFilterBuilder extends PostgrestTransformBuilder_1.default{/**\n     * Match only rows where `column` is equal to `value`.\n     *\n     * To check if the value of `column` is NULL, you should use `.is()` instead.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */eq(column,value){this.url.searchParams.append(column,`eq.${value}`);return this;}/**\n     * Match only rows where `column` is not equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */neq(column,value){this.url.searchParams.append(column,`neq.${value}`);return this;}/**\n     * Match only rows where `column` is greater than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */gt(column,value){this.url.searchParams.append(column,`gt.${value}`);return this;}/**\n     * Match only rows where `column` is greater than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */gte(column,value){this.url.searchParams.append(column,`gte.${value}`);return this;}/**\n     * Match only rows where `column` is less than `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */lt(column,value){this.url.searchParams.append(column,`lt.${value}`);return this;}/**\n     * Match only rows where `column` is less than or equal to `value`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */lte(column,value){this.url.searchParams.append(column,`lte.${value}`);return this;}/**\n     * Match only rows where `column` matches `pattern` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */like(column,pattern){this.url.searchParams.append(column,`like.${pattern}`);return this;}/**\n     * Match only rows where `column` matches all of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */likeAllOf(column,patterns){this.url.searchParams.append(column,`like(all).{${patterns.join(',')}}`);return this;}/**\n     * Match only rows where `column` matches any of `patterns` case-sensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */likeAnyOf(column,patterns){this.url.searchParams.append(column,`like(any).{${patterns.join(',')}}`);return this;}/**\n     * Match only rows where `column` matches `pattern` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param pattern - The pattern to match with\n     */ilike(column,pattern){this.url.searchParams.append(column,`ilike.${pattern}`);return this;}/**\n     * Match only rows where `column` matches all of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ilikeAllOf(column,patterns){this.url.searchParams.append(column,`ilike(all).{${patterns.join(',')}}`);return this;}/**\n     * Match only rows where `column` matches any of `patterns` case-insensitively.\n     *\n     * @param column - The column to filter on\n     * @param patterns - The patterns to match with\n     */ilikeAnyOf(column,patterns){this.url.searchParams.append(column,`ilike(any).{${patterns.join(',')}}`);return this;}/**\n     * Match only rows where `column` IS `value`.\n     *\n     * For non-boolean columns, this is only relevant for checking if the value of\n     * `column` is NULL by setting `value` to `null`.\n     *\n     * For boolean columns, you can also set `value` to `true` or `false` and it\n     * will behave the same way as `.eq()`.\n     *\n     * @param column - The column to filter on\n     * @param value - The value to filter with\n     */is(column,value){this.url.searchParams.append(column,`is.${value}`);return this;}/**\n     * Match only rows where `column` is included in the `values` array.\n     *\n     * @param column - The column to filter on\n     * @param values - The values array to filter with\n     */in(column,values){const cleanedValues=Array.from(new Set(values)).map(s=>{// handle postgrest reserved characters\n// https://postgrest.org/en/v7.0.0/api.html#reserved-characters\nif(typeof s==='string'&&new RegExp('[,()]').test(s))return`\"${s}\"`;else return`${s}`;}).join(',');this.url.searchParams.append(column,`in.(${cleanedValues})`);return this;}/**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * `column` contains every element appearing in `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */contains(column,value){if(typeof value==='string'){// range types can be inclusive '[', ']' or exclusive '(', ')' so just\n// keep it simple and accept a string\nthis.url.searchParams.append(column,`cs.${value}`);}else if(Array.isArray(value)){// array\nthis.url.searchParams.append(column,`cs.{${value.join(',')}}`);}else{// json\nthis.url.searchParams.append(column,`cs.${JSON.stringify(value)}`);}return this;}/**\n     * Only relevant for jsonb, array, and range columns. Match only rows where\n     * every element appearing in `column` is contained by `value`.\n     *\n     * @param column - The jsonb, array, or range column to filter on\n     * @param value - The jsonb, array, or range value to filter with\n     */containedBy(column,value){if(typeof value==='string'){// range\nthis.url.searchParams.append(column,`cd.${value}`);}else if(Array.isArray(value)){// array\nthis.url.searchParams.append(column,`cd.{${value.join(',')}}`);}else{// json\nthis.url.searchParams.append(column,`cd.${JSON.stringify(value)}`);}return this;}/**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is greater than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */rangeGt(column,range){this.url.searchParams.append(column,`sr.${range}`);return this;}/**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or greater than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */rangeGte(column,range){this.url.searchParams.append(column,`nxl.${range}`);return this;}/**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is less than any element in `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */rangeLt(column,range){this.url.searchParams.append(column,`sl.${range}`);return this;}/**\n     * Only relevant for range columns. Match only rows where every element in\n     * `column` is either contained in `range` or less than any element in\n     * `range`.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */rangeLte(column,range){this.url.searchParams.append(column,`nxr.${range}`);return this;}/**\n     * Only relevant for range columns. Match only rows where `column` is\n     * mutually exclusive to `range` and there can be no element between the two\n     * ranges.\n     *\n     * @param column - The range column to filter on\n     * @param range - The range to filter with\n     */rangeAdjacent(column,range){this.url.searchParams.append(column,`adj.${range}`);return this;}/**\n     * Only relevant for array and range columns. Match only rows where\n     * `column` and `value` have an element in common.\n     *\n     * @param column - The array or range column to filter on\n     * @param value - The array or range value to filter with\n     */overlaps(column,value){if(typeof value==='string'){// range\nthis.url.searchParams.append(column,`ov.${value}`);}else{// array\nthis.url.searchParams.append(column,`ov.{${value.join(',')}}`);}return this;}/**\n     * Only relevant for text and tsvector columns. Match only rows where\n     * `column` matches the query string in `query`.\n     *\n     * @param column - The text or tsvector column to filter on\n     * @param query - The query text to match with\n     * @param options - Named parameters\n     * @param options.config - The text search configuration to use\n     * @param options.type - Change how the `query` text is interpreted\n     */textSearch(column,query){let{config,type}=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};let typePart='';if(type==='plain'){typePart='pl';}else if(type==='phrase'){typePart='ph';}else if(type==='websearch'){typePart='w';}const configPart=config===undefined?'':`(${config})`;this.url.searchParams.append(column,`${typePart}fts${configPart}.${query}`);return this;}/**\n     * Match only rows where each column in `query` keys is equal to its\n     * associated value. Shorthand for multiple `.eq()`s.\n     *\n     * @param query - The object to filter with, with column names as keys mapped\n     * to their filter values\n     */match(query){Object.entries(query).forEach(_ref=>{let[column,value]=_ref;this.url.searchParams.append(column,`eq.${value}`);});return this;}/**\n     * Match only rows which doesn't satisfy the filter.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to be negated to filter with, following\n     * PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */not(column,operator,value){this.url.searchParams.append(column,`not.${operator}.${value}`);return this;}/**\n     * Match only rows which satisfy at least one of the filters.\n     *\n     * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure it's properly sanitized.\n     *\n     * It's currently not possible to do an `.or()` filter across multiple tables.\n     *\n     * @param filters - The filters to use, following PostgREST syntax\n     * @param options - Named parameters\n     * @param options.referencedTable - Set this to filter on referenced tables\n     * instead of the parent table\n     * @param options.foreignTable - Deprecated, use `referencedTable` instead\n     */or(filters){let{foreignTable,referencedTable=foreignTable}=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};const key=referencedTable?`${referencedTable}.or`:'or';this.url.searchParams.append(key,`(${filters})`);return this;}/**\n     * Match only rows which satisfy the filter. This is an escape hatch - you\n     * should use the specific filter methods wherever possible.\n     *\n     * Unlike most filters, `opearator` and `value` are used as-is and need to\n     * follow [PostgREST\n     * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n     * to make sure they are properly sanitized.\n     *\n     * @param column - The column to filter on\n     * @param operator - The operator to filter with, following PostgREST syntax\n     * @param value - The value to filter with, following PostgREST syntax\n     */filter(column,operator,value){this.url.searchParams.append(column,`${operator}.${value}`);return this;}}exports.default=PostgrestFilterBuilder;","map":{"version":3,"names":["PostgrestTransformBuilder_1","__importDefault","require","PostgrestFilterBuilder","default","eq","column","value","url","searchParams","append","neq","gt","gte","lt","lte","like","pattern","likeAllOf","patterns","join","likeAnyOf","ilike","ilikeAllOf","ilikeAnyOf","is","in","values","cleanedValues","Array","from","Set","map","s","RegExp","test","contains","isArray","JSON","stringify","containedBy","rangeGt","range","rangeGte","rangeLt","rangeLte","rangeAdjacent","overlaps","textSearch","query","config","type","arguments","length","undefined","typePart","configPart","match","Object","entries","forEach","_ref","not","operator","or","filters","foreignTable","referencedTable","key","filter","exports"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/postgrest-js/src/PostgrestFilterBuilder.ts"],"sourcesContent":["import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { JsonPathToAccessor, JsonPathToType } from './select-query-parser/utils'\nimport { GenericSchema } from './types'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n\nexport type IsStringOperator<Path extends string> = Path extends `${string}->>${string}`\n  ? true\n  : false\n\n// Match relationship filters with `table.column` syntax and resolve underlying\n// column value. If not matched, fallback to generic type.\n// TODO: Validate the relationship itself ala select-query-parser. Currently we\n// assume that all tables have valid relationships to each other, despite\n// nonexistent foreign keys.\ntype ResolveFilterValue<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  ColumnName extends string\n> = ColumnName extends `${infer RelationshipTable}.${infer Remainder}`\n  ? Remainder extends `${infer _}.${infer _}`\n    ? ResolveFilterValue<Schema, Row, Remainder>\n    : ResolveFilterRelationshipValue<Schema, RelationshipTable, Remainder>\n  : ColumnName extends keyof Row\n  ? Row[ColumnName]\n  : // If the column selection is a jsonpath like `data->value` or `data->>value` we attempt to match\n  // the expected type with the parsed custom json type\n  IsStringOperator<ColumnName> extends true\n  ? string\n  : JsonPathToType<Row, JsonPathToAccessor<ColumnName>> extends infer JsonPathValue\n  ? JsonPathValue extends never\n    ? never\n    : JsonPathValue\n  : never\n\ntype ResolveFilterRelationshipValue<\n  Schema extends GenericSchema,\n  RelationshipTable extends string,\n  RelationshipColumn extends string\n> = Schema['Tables'] & Schema['Views'] extends infer TablesAndViews\n  ? RelationshipTable extends keyof TablesAndViews\n    ? 'Row' extends keyof TablesAndViews[RelationshipTable]\n      ? RelationshipColumn extends keyof TablesAndViews[RelationshipTable]['Row']\n        ? TablesAndViews[RelationshipTable]['Row'][RelationshipColumn]\n        : unknown\n      : unknown\n    : unknown\n  : never\n\nexport default class PostgrestFilterBuilder<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown\n> extends PostgrestTransformBuilder<Schema, Row, Result, RelationName, Relationships> {\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? NonNullable<unknown>\n      : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n      // type resolution error\n      ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? NonNullable<ResolvedFilterValue>\n      : // We should never enter this case as all the branches are covered above\n        never\n  ): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n      ? ResolvedFilterValue\n      : never\n  ): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n        // type resolution error\n        ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : // We should never enter this case as all the branches are covered above\n          never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && new RegExp('[,()]').test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]>\n  ): this\n  overlaps(column: string, value: string | readonly unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | readonly unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to filter on referenced tables\n   * instead of the parent table\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\n   */\n  or(\n    filters: string,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n"],"mappings":"qLAAA,MAAAA,2BAAA,CAAAC,eAAA,CAAAC,OAAA,iCAuEA,KAAqB,CAAAC,sBAMnB,QAAQ,CAAAH,2BAAA,CAAAI,OAA2E,CACnF;;;;;;;OAQAC,EAAEA,CACAC,MAAkB,CAClBC,KAOS,EAET,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,CACnD,MAAO,KAAI,CACb,CAEA;;;;;OAMAI,GAAGA,CACDL,MAAkB,CAClBC,KAIS,EAET,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOC,KAAK,EAAE,CAAC,CACpD,MAAO,KAAI,CACb,CAIA;;;;;OAMAK,EAAEA,CAACN,MAAc,CAAEC,KAAc,EAC/B,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,CACnD,MAAO,KAAI,CACb,CAIA;;;;;OAMAM,GAAGA,CAACP,MAAc,CAAEC,KAAc,EAChC,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOC,KAAK,EAAE,CAAC,CACpD,MAAO,KAAI,CACb,CAIA;;;;;OAMAO,EAAEA,CAACR,MAAc,CAAEC,KAAc,EAC/B,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,CACnD,MAAO,KAAI,CACb,CAIA;;;;;OAMAQ,GAAGA,CAACT,MAAc,CAAEC,KAAc,EAChC,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOC,KAAK,EAAE,CAAC,CACpD,MAAO,KAAI,CACb,CAIA;;;;;OAMAS,IAAIA,CAACV,MAAc,CAAEW,OAAe,EAClC,IAAI,CAACT,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,QAAQW,OAAO,EAAE,CAAC,CACvD,MAAO,KAAI,CACb,CAOA;;;;;OAMAC,SAASA,CAACZ,MAAc,CAAEa,QAA2B,EACnD,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,cAAca,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CACzE,MAAO,KAAI,CACb,CAOA;;;;;OAMAC,SAASA,CAACf,MAAc,CAAEa,QAA2B,EACnD,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,cAAca,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CACzE,MAAO,KAAI,CACb,CAIA;;;;;OAMAE,KAAKA,CAAChB,MAAc,CAAEW,OAAe,EACnC,IAAI,CAACT,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,SAASW,OAAO,EAAE,CAAC,CACxD,MAAO,KAAI,CACb,CAOA;;;;;OAMAM,UAAUA,CAACjB,MAAc,CAAEa,QAA2B,EACpD,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,eAAea,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAC1E,MAAO,KAAI,CACb,CAOA;;;;;OAMAI,UAAUA,CAAClB,MAAc,CAAEa,QAA2B,EACpD,IAAI,CAACX,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,eAAea,QAAQ,CAACC,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,CAC1E,MAAO,KAAI,CACb,CAOA;;;;;;;;;;;OAYAK,EAAEA,CAACnB,MAAc,CAAEC,KAAqB,EACtC,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,CACnD,MAAO,KAAI,CACb,CAEA;;;;;OAMAmB,EAAEA,CACApB,MAAkB,CAClBqB,MASC,EAED,KAAM,CAAAC,aAAa,CAAGC,KAAK,CAACC,IAAI,CAAC,GAAI,CAAAC,GAAG,CAACJ,MAAM,CAAC,CAAC,CAC9CK,GAAG,CAAEC,CAAC,EAAI,CACT;AACA;AACA,GAAI,MAAO,CAAAA,CAAC,GAAK,QAAQ,EAAI,GAAI,CAAAC,MAAM,CAAC,OAAO,CAAC,CAACC,IAAI,CAACF,CAAC,CAAC,CAAE,MAAO,IAAIA,CAAC,GAAG,KACpE,OAAO,GAAGA,CAAC,EAAE,CACpB,CAAC,CAAC,CACDb,IAAI,CAAC,GAAG,CAAC,CACZ,IAAI,CAACZ,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOsB,aAAa,GAAG,CAAC,CAC7D,MAAO,KAAI,CACb,CAOA;;;;;;OAOAQ,QAAQA,CAAC9B,MAAc,CAAEC,KAA4D,EACnF,GAAI,MAAO,CAAAA,KAAK,GAAK,QAAQ,CAAE,CAC7B;AACA;AACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,C,CACpD,IAAM,IAAIsB,KAAK,CAACQ,OAAO,CAAC9B,KAAK,CAAC,CAAE,CAC/B;AACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOC,KAAK,CAACa,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,C,CAChE,IAAM,CACL;AACA,IAAI,CAACZ,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMgC,IAAI,CAACC,SAAS,CAAChC,KAAK,CAAC,EAAE,CAAC,C,CAErE,MAAO,KAAI,CACb,CAOA;;;;;;OAOAiC,WAAWA,CAAClC,MAAc,CAAEC,KAA4D,EACtF,GAAI,MAAO,CAAAA,KAAK,GAAK,QAAQ,CAAE,CAC7B;AACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,C,CACpD,IAAM,IAAIsB,KAAK,CAACQ,OAAO,CAAC9B,KAAK,CAAC,CAAE,CAC/B;AACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOC,KAAK,CAACa,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,C,CAChE,IAAM,CACL;AACA,IAAI,CAACZ,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMgC,IAAI,CAACC,SAAS,CAAChC,KAAK,CAAC,EAAE,CAAC,C,CAErE,MAAO,KAAI,CACb,CAIA;;;;;;OAOAkC,OAAOA,CAACnC,MAAc,CAAEoC,KAAa,EACnC,IAAI,CAAClC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMoC,KAAK,EAAE,CAAC,CACnD,MAAO,KAAI,CACb,CAIA;;;;;;;OAQAC,QAAQA,CAACrC,MAAc,CAAEoC,KAAa,EACpC,IAAI,CAAClC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOoC,KAAK,EAAE,CAAC,CACpD,MAAO,KAAI,CACb,CAIA;;;;;;OAOAE,OAAOA,CAACtC,MAAc,CAAEoC,KAAa,EACnC,IAAI,CAAClC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMoC,KAAK,EAAE,CAAC,CACnD,MAAO,KAAI,CACb,CAIA;;;;;;;OAQAG,QAAQA,CAACvC,MAAc,CAAEoC,KAAa,EACpC,IAAI,CAAClC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOoC,KAAK,EAAE,CAAC,CACpD,MAAO,KAAI,CACb,CAIA;;;;;;;OAQAI,aAAaA,CAACxC,MAAc,CAAEoC,KAAa,EACzC,IAAI,CAAClC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOoC,KAAK,EAAE,CAAC,CACpD,MAAO,KAAI,CACb,CAOA;;;;;;OAOAK,QAAQA,CAACzC,MAAc,CAAEC,KAAkC,EACzD,GAAI,MAAO,CAAAA,KAAK,GAAK,QAAQ,CAAE,CAC7B;AACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,C,CACpD,IAAM,CACL;AACA,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOC,KAAK,CAACa,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,C,CAEjE,MAAO,KAAI,CACb,CAYA;;;;;;;;;OAUA4B,UAAUA,CACR1C,MAAc,CACd2C,KAAa,CACsE,IAAnF,CAAEC,MAAM,CAAEC,IAAI,EAAAC,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IAAmE,EAAE,CAEnF,GAAI,CAAAG,QAAQ,CAAG,EAAE,CACjB,GAAIJ,IAAI,GAAK,OAAO,CAAE,CACpBI,QAAQ,CAAG,IAAI,C,CAChB,IAAM,IAAIJ,IAAI,GAAK,QAAQ,CAAE,CAC5BI,QAAQ,CAAG,IAAI,C,CAChB,IAAM,IAAIJ,IAAI,GAAK,WAAW,CAAE,CAC/BI,QAAQ,CAAG,GAAG,C,CAEhB,KAAM,CAAAC,UAAU,CAAGN,MAAM,GAAKI,SAAS,CAAG,EAAE,CAAG,IAAIJ,MAAM,GAAG,CAC5D,IAAI,CAAC1C,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,GAAGiD,QAAQ,MAAMC,UAAU,IAAIP,KAAK,EAAE,CAAC,CAC5E,MAAO,KAAI,CACb,CAIA;;;;;;OAOAQ,KAAKA,CAACR,KAA8B,EAClCS,MAAM,CAACC,OAAO,CAACV,KAAK,CAAC,CAACW,OAAO,CAACC,IAAA,EAAoB,IAAnB,CAACvD,MAAM,CAAEC,KAAK,CAAC,CAAAsD,IAAA,CAC5C,IAAI,CAACrD,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,MAAMC,KAAK,EAAE,CAAC,CACrD,CAAC,CAAC,CACF,MAAO,KAAI,CACb,CAQA;;;;;;;;;;;;OAaAuD,GAAGA,CAACxD,MAAc,CAAEyD,QAAgB,CAAExD,KAAc,EAClD,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,OAAOyD,QAAQ,IAAIxD,KAAK,EAAE,CAAC,CAChE,MAAO,KAAI,CACb,CAEA;;;;;;;;;;;;;;OAeAyD,EAAEA,CACAC,OAAe,CAI4C,IAH3D,CACEC,YAAY,CACZC,eAAe,CAAGD,YAAY,EAAAd,SAAA,CAAAC,MAAA,IAAAD,SAAA,MAAAE,SAAA,CAAAF,SAAA,IACyB,EAAE,CAE3D,KAAM,CAAAgB,GAAG,CAAGD,eAAe,CAAG,GAAGA,eAAe,KAAK,CAAG,IAAI,CAC5D,IAAI,CAAC3D,GAAG,CAACC,YAAY,CAACC,MAAM,CAAC0D,GAAG,CAAE,IAAIH,OAAO,GAAG,CAAC,CACjD,MAAO,KAAI,CACb,CAQA;;;;;;;;;;;;OAaAI,MAAMA,CAAC/D,MAAc,CAAEyD,QAAgB,CAAExD,KAAc,EACrD,IAAI,CAACC,GAAG,CAACC,YAAY,CAACC,MAAM,CAACJ,MAAM,CAAE,GAAGyD,QAAQ,IAAIxD,KAAK,EAAE,CAAC,CAC5D,MAAO,KAAI,CACb,C,CAvgBF+D,OAAA,CAAAlE,OAAA,CAAAD,sBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}