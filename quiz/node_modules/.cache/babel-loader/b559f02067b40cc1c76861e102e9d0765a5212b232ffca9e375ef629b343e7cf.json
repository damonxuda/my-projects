{"ast":null,"code":"var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){function adopt(value){return value instanceof P?value:new P(function(resolve){resolve(value);});}return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value));}catch(e){reject(e);}}function rejected(value){try{step(generator[\"throw\"](value));}catch(e){reject(e);}}function step(result){result.done?resolve(result.value):adopt(result.value).then(fulfilled,rejected);}step((generator=generator.apply(thisArg,_arguments||[])).next());});};import{DEFAULT_HEADERS}from'../lib/constants';import{isStorageError}from'../lib/errors';import{get,post,put,remove}from'../lib/fetch';import{resolveFetch}from'../lib/helpers';export default class StorageBucketApi{constructor(url){let headers=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};let fetch=arguments.length>2?arguments[2]:undefined;let opts=arguments.length>3?arguments[3]:undefined;const baseUrl=new URL(url);// if legacy uri is used, replace with new storage host (disables request buffering to allow > 50GB uploads)\n// \"project-ref.supabase.co\" becomes \"project-ref.storage.supabase.co\"\nif(opts===null||opts===void 0?void 0:opts.useNewHostname){const isSupabaseHost=/supabase\\.(co|in|red)$/.test(baseUrl.hostname);if(isSupabaseHost&&!baseUrl.hostname.includes('storage.supabase.')){baseUrl.hostname=baseUrl.hostname.replace('supabase.','storage.supabase.');}}this.url=baseUrl.href;this.headers=Object.assign(Object.assign({},DEFAULT_HEADERS),headers);this.fetch=resolveFetch(fetch);}/**\n     * Retrieves the details of all Storage buckets within an existing project.\n     */listBuckets(){return __awaiter(this,void 0,void 0,function*(){try{const data=yield get(this.fetch,\"\".concat(this.url,\"/bucket\"),{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Retrieves the details of an existing Storage bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to retrieve.\n     */getBucket(id){return __awaiter(this,void 0,void 0,function*(){try{const data=yield get(this.fetch,\"\".concat(this.url,\"/bucket/\").concat(id),{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Creates a new Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are creating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     * @returns newly created bucket id\n     * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n     *   - default bucket type is `STANDARD`\n     */createBucket(id){let options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{public:false};return __awaiter(this,void 0,void 0,function*(){try{const data=yield post(this.fetch,\"\".concat(this.url,\"/bucket\"),{id,name:id,type:options.type,public:options.public,file_size_limit:options.fileSizeLimit,allowed_mime_types:options.allowedMimeTypes},{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Updates a Storage bucket\n     *\n     * @param id A unique identifier for the bucket you are updating.\n     * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n     * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n     * The global file size limit takes precedence over this value.\n     * The default value is null, which doesn't set a per bucket file size limit.\n     * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n     * The default value is null, which allows files with all mime types to be uploaded.\n     * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n     */updateBucket(id,options){return __awaiter(this,void 0,void 0,function*(){try{const data=yield put(this.fetch,\"\".concat(this.url,\"/bucket/\").concat(id),{id,name:id,public:options.public,file_size_limit:options.fileSizeLimit,allowed_mime_types:options.allowedMimeTypes},{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Removes all objects inside a single bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to empty.\n     */emptyBucket(id){return __awaiter(this,void 0,void 0,function*(){try{const data=yield post(this.fetch,\"\".concat(this.url,\"/bucket/\").concat(id,\"/empty\"),{},{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}/**\n     * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n     * You must first `empty()` the bucket.\n     *\n     * @param id The unique identifier of the bucket you would like to delete.\n     */deleteBucket(id){return __awaiter(this,void 0,void 0,function*(){try{const data=yield remove(this.fetch,\"\".concat(this.url,\"/bucket/\").concat(id),{},{headers:this.headers});return{data,error:null};}catch(error){if(isStorageError(error)){return{data:null,error};}throw error;}});}}","map":{"version":3,"names":["DEFAULT_HEADERS","isStorageError","get","post","put","remove","resolveFetch","StorageBucketApi","constructor","url","headers","arguments","length","undefined","fetch","opts","baseUrl","URL","useNewHostname","isSupabaseHost","test","hostname","includes","replace","href","Object","assign","listBuckets","data","concat","error","getBucket","id","createBucket","options","public","name","type","file_size_limit","fileSizeLimit","allowed_mime_types","allowedMimeTypes","updateBucket","emptyBucket","deleteBucket"],"sources":["/Users/damonxu/Documents/GitHub/my-projects/auth/node_modules/@supabase/storage-js/src/packages/StorageBucketApi.ts"],"sourcesContent":["import { DEFAULT_HEADERS } from '../lib/constants'\nimport { isStorageError, StorageError } from '../lib/errors'\nimport { Fetch, get, post, put, remove } from '../lib/fetch'\nimport { resolveFetch } from '../lib/helpers'\nimport { Bucket, BucketType } from '../lib/types'\nimport { StorageClientOptions } from '../StorageClient'\n\nexport default class StorageBucketApi {\n  protected url: string\n  protected headers: { [key: string]: string }\n  protected fetch: Fetch\n\n  constructor(\n    url: string,\n    headers: { [key: string]: string } = {},\n    fetch?: Fetch,\n    opts?: StorageClientOptions\n  ) {\n    const baseUrl = new URL(url)\n\n    // if legacy uri is used, replace with new storage host (disables request buffering to allow > 50GB uploads)\n    // \"project-ref.supabase.co\" becomes \"project-ref.storage.supabase.co\"\n    if (opts?.useNewHostname) {\n      const isSupabaseHost = /supabase\\.(co|in|red)$/.test(baseUrl.hostname)\n      if (isSupabaseHost && !baseUrl.hostname.includes('storage.supabase.')) {\n        baseUrl.hostname = baseUrl.hostname.replace('supabase.', 'storage.supabase.')\n      }\n    }\n\n    this.url = baseUrl.href\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\n    this.fetch = resolveFetch(fetch)\n  }\n\n  /**\n   * Retrieves the details of all Storage buckets within an existing project.\n   */\n  async listBuckets(): Promise<\n    | {\n        data: Bucket[]\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Retrieves the details of an existing Storage bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to retrieve.\n   */\n  async getBucket(\n    id: string\n  ): Promise<\n    | {\n        data: Bucket\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await get(this.fetch, `${this.url}/bucket/${id}`, { headers: this.headers })\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Creates a new Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are creating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations. By default, buckets are private.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   * @returns newly created bucket id\n   * @param options.type (private-beta) specifies the bucket type. see `BucketType` for more details.\n   *   - default bucket type is `STANDARD`\n   */\n  async createBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n      type?: BucketType\n    } = {\n      public: false,\n    }\n  ): Promise<\n    | {\n        data: Pick<Bucket, 'name'>\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket`,\n        {\n          id,\n          name: id,\n          type: options.type,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates a Storage bucket\n   *\n   * @param id A unique identifier for the bucket you are updating.\n   * @param options.public The visibility of the bucket. Public buckets don't require an authorization token to download objects, but still require a valid token for all other operations.\n   * @param options.fileSizeLimit specifies the max file size in bytes that can be uploaded to this bucket.\n   * The global file size limit takes precedence over this value.\n   * The default value is null, which doesn't set a per bucket file size limit.\n   * @param options.allowedMimeTypes specifies the allowed mime types that this bucket can accept during upload.\n   * The default value is null, which allows files with all mime types to be uploaded.\n   * Each mime type specified can be a wildcard, e.g. image/*, or a specific mime type, e.g. image/png.\n   */\n  async updateBucket(\n    id: string,\n    options: {\n      public: boolean\n      fileSizeLimit?: number | string | null\n      allowedMimeTypes?: string[] | null\n    }\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await put(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {\n          id,\n          name: id,\n          public: options.public,\n          file_size_limit: options.fileSizeLimit,\n          allowed_mime_types: options.allowedMimeTypes,\n        },\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Removes all objects inside a single bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to empty.\n   */\n  async emptyBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await post(\n        this.fetch,\n        `${this.url}/bucket/${id}/empty`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Deletes an existing bucket. A bucket can't be deleted with existing objects inside it.\n   * You must first `empty()` the bucket.\n   *\n   * @param id The unique identifier of the bucket you would like to delete.\n   */\n  async deleteBucket(\n    id: string\n  ): Promise<\n    | {\n        data: { message: string }\n        error: null\n      }\n    | {\n        data: null\n        error: StorageError\n      }\n  > {\n    try {\n      const data = await remove(\n        this.fetch,\n        `${this.url}/bucket/${id}`,\n        {},\n        { headers: this.headers }\n      )\n      return { data, error: null }\n    } catch (error) {\n      if (isStorageError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}